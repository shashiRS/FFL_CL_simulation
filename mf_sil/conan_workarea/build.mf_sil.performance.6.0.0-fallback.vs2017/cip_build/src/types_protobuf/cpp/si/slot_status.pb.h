// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: si/slot_status.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_si_2fslot_5fstatus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_si_2fslot_5fstatus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_si_2fslot_5fstatus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_si_2fslot_5fstatus_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_si_2fslot_5fstatus_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace pb {
namespace si {
namespace slot_status {

enum SlotStatus : int {
  UNKNOWN = 0,
  VALID = 1,
  INVALID_OPENING = 2,
  INVALID_WINDOW = 3,
  NOT_MATCHING_WINDOW = 4,
  SLOT_ALREADY_KNOWN = 5,
  SLOT_INVALIDATED_BY_OVERLAP_WITH_HIGHER_PRIO = 6,
  SIDE_OR_CURB_OBJECTS_MISSING = 7,
  TOO_MANY_ITERATIONS_IN_SHRINKING = 8,
  NO_VALID_SHIFT_VECTOR_FOUND = 9,
  SLOT_TOO_SMALL_AFTER_SHRINKING = 10,
  SLOT_INVALID_BY_DEF = 11,
  SLOT_PARALLEL_WINDOW_VALID = 12,
  SLOT_PARALLEL_WINDOW_INVALID = 13,
  SLOT_PERP_WINDOW_VALID = 14,
  SLOT_PERP_WINDOW_INVALID = 15,
  SLOT_GARAGE_WINDOW_VALID = 16,
  SLOT_GARAGE_WINDOW_INVALID = 17,
  SLOT_ANGLED_WINDOW_VALID = 18,
  SLOT_ANGLED_WINDOW_INVALID = 19,
  SLOT_NOT_RECTANGULAR = 20,
  SLOT_OPENING_TOO_SHORT = 21,
  SLOT_OPENING_TOO_LONG = 22,
  SLOT_DEPTH_TOO_SHORT = 23,
  SLOT_DEPTH_TOO_LONG = 24,
  SLOT_ORIENTATION_OVER_THRESHOLD = 25,
  SIDE_DELIMITER_INVALID = 26,
  SI_LOW_MINI_EM_OVERFLOW = 27,
  SLOT_NOT_OVERLAPPING_EGO = 28,
  SLOT_ROTATED_TOO_FAR = 29,
  SLOT_NOT_VALIDATED_BY_CNN_SLOT = 30,
  SLOT_IS_INVALIDATED_BY_CNN_SLOT = 31,
  SLOT_EXTENDED_BEYOND_LINE_TOO_FAR = 32
};
bool SlotStatus_IsValid(int value);
constexpr SlotStatus SlotStatus_MIN = UNKNOWN;
constexpr SlotStatus SlotStatus_MAX = SLOT_EXTENDED_BEYOND_LINE_TOO_FAR;
constexpr int SlotStatus_ARRAYSIZE = SlotStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SlotStatus_descriptor();
template<typename T>
inline const std::string& SlotStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SlotStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SlotStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SlotStatus_descriptor(), enum_t_value);
}
inline bool SlotStatus_Parse(
    const std::string& name, SlotStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SlotStatus>(
    SlotStatus_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace slot_status
}  // namespace si
}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::si::slot_status::SlotStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::si::slot_status::SlotStatus>() {
  return ::pb::si::slot_status::SlotStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_si_2fslot_5fstatus_2eproto
