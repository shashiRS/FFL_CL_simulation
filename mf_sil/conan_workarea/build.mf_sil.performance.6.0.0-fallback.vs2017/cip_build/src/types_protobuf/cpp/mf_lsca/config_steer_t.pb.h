// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mf_lsca/config_steer_t.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mf_5flsca_2fconfig_5fsteer_5ft_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mf_5flsca_2fconfig_5fsteer_5ft_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "mf_lsca/config_steer_propose_t.pb.h"
#include "cml/vec2_df_pod.pb.h"
#include "mf_lsca/config_steer_resist_t.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mf_5flsca_2fconfig_5fsteer_5ft_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mf_5flsca_2fconfig_5fsteer_5ft_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mf_5flsca_2fconfig_5fsteer_5ft_2eproto;
namespace pb {
namespace mf_lsca {
namespace config_steer_t {
class configSteer_t;
class configSteer_tDefaultTypeInternal;
extern configSteer_tDefaultTypeInternal _configSteer_t_default_instance_;
class configSteer_t_array_port;
class configSteer_t_array_portDefaultTypeInternal;
extern configSteer_t_array_portDefaultTypeInternal _configSteer_t_array_port_default_instance_;
}  // namespace config_steer_t
}  // namespace mf_lsca
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::mf_lsca::config_steer_t::configSteer_t* Arena::CreateMaybeMessage<::pb::mf_lsca::config_steer_t::configSteer_t>(Arena*);
template<> ::pb::mf_lsca::config_steer_t::configSteer_t_array_port* Arena::CreateMaybeMessage<::pb::mf_lsca::config_steer_t::configSteer_t_array_port>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {
namespace mf_lsca {
namespace config_steer_t {

// ===================================================================

class configSteer_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.mf_lsca.config_steer_t.configSteer_t) */ {
 public:
  configSteer_t();
  virtual ~configSteer_t();

  configSteer_t(const configSteer_t& from);
  configSteer_t(configSteer_t&& from) noexcept
    : configSteer_t() {
    *this = ::std::move(from);
  }

  inline configSteer_t& operator=(const configSteer_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline configSteer_t& operator=(configSteer_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const configSteer_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const configSteer_t* internal_default_instance() {
    return reinterpret_cast<const configSteer_t*>(
               &_configSteer_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(configSteer_t& a, configSteer_t& b) {
    a.Swap(&b);
  }
  inline void Swap(configSteer_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline configSteer_t* New() const final {
    return CreateMaybeMessage<configSteer_t>(nullptr);
  }

  configSteer_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<configSteer_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const configSteer_t& from);
  void MergeFrom(const configSteer_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(configSteer_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.mf_lsca.config_steer_t.configSteer_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mf_5flsca_2fconfig_5fsteer_5ft_2eproto);
    return ::descriptor_table_mf_5flsca_2fconfig_5fsteer_5ft_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxSteeringAngleLimitsDegFieldNumber = 336,
    kMaxSteeringTorqueLimitsNmFieldNumber = 1822,
    kResistanceDataFieldNumber = 1940,
    kMaxSteeringTorqueDeltaNmsFieldNumber = 2200,
    kProposalDataFieldNumber = 3670,
    kMaxSteeringAngleDeltaDegFieldNumber = 3987,
    kUpperDeactivationSpeedBackwardsMsFieldNumber = 227,
    kEnlargementSideMFieldNumber = 262,
    kRoiTravelledDistOffsetResistMFieldNumber = 663,
    kOverrideTimeSFieldNumber = 688,
    kRoiWidthSFieldNumber = 707,
    kLowerDeactivationSpeedBackwardsMsFieldNumber = 827,
    kLowerDeactivationSpeedForwardsMsFieldNumber = 885,
    kRoiTravelledDistResistSFieldNumber = 1271,
    kEnlargementRearMFieldNumber = 1339,
    kImmediateOverrideTorqueNmFieldNumber = 1533,
    kUpperDeactivationSpeedForwardsMsFieldNumber = 1789,
    kLowerActivationSpeedForwardsMsFieldNumber = 1858,
    kRearSteerAngleRatioFieldNumber = 1939,
    kRoiTravelledDistPropSFieldNumber = 2008,
    kRoiLengthSFieldNumber = 2236,
    kMinDynamicObjectProbabilityPercFieldNumber = 2440,
    kCheckSeatNuFieldNumber = 3889,
    kTorqueInterfaceActiveNuFieldNumber = 1116,
    kStopInterventionIfErrorNuFieldNumber = 3855,
    kCheckDoorsNuFieldNumber = 2707,
    kCheckDriverSeatbeltNuFieldNumber = 1677,
    kCheckTrunkNuFieldNumber = 1989,
    kLowerActivationSpeedBackwardsMsFieldNumber = 2600,
    kUpperActivationSpeedBackwardsMsFieldNumber = 2668,
    kRoiTravelledDistOffsetPropMFieldNumber = 2806,
    kRoiLengthOffsetMFieldNumber = 3175,
    kMinStaticObjectProbabilityPercFieldNumber = 3245,
    kTimeBasedOverrideTorqueNmFieldNumber = 3376,
    kRoiWidthOffsetMFieldNumber = 3478,
    kEnlargementFrontMFieldNumber = 3610,
    kUpperActivationSpeedForwardsMsFieldNumber = 3994,
    kOverrideDistanceMFieldNumber = 3439220,
  };
  // optional .pb.cml.vec2_df_pod.Vec2Df_POD maxSteeringAngleLimits_deg = 336;
  bool has_maxsteeringanglelimits_deg() const;
  private:
  bool _internal_has_maxsteeringanglelimits_deg() const;
  public:
  void clear_maxsteeringanglelimits_deg();
  const ::pb::cml::vec2_df_pod::Vec2Df_POD& maxsteeringanglelimits_deg() const;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* release_maxsteeringanglelimits_deg();
  ::pb::cml::vec2_df_pod::Vec2Df_POD* mutable_maxsteeringanglelimits_deg();
  void set_allocated_maxsteeringanglelimits_deg(::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringanglelimits_deg);
  private:
  const ::pb::cml::vec2_df_pod::Vec2Df_POD& _internal_maxsteeringanglelimits_deg() const;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* _internal_mutable_maxsteeringanglelimits_deg();
  public:

  // optional .pb.cml.vec2_df_pod.Vec2Df_POD maxSteeringTorqueLimits_Nm = 1822;
  bool has_maxsteeringtorquelimits_nm() const;
  private:
  bool _internal_has_maxsteeringtorquelimits_nm() const;
  public:
  void clear_maxsteeringtorquelimits_nm();
  const ::pb::cml::vec2_df_pod::Vec2Df_POD& maxsteeringtorquelimits_nm() const;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* release_maxsteeringtorquelimits_nm();
  ::pb::cml::vec2_df_pod::Vec2Df_POD* mutable_maxsteeringtorquelimits_nm();
  void set_allocated_maxsteeringtorquelimits_nm(::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringtorquelimits_nm);
  private:
  const ::pb::cml::vec2_df_pod::Vec2Df_POD& _internal_maxsteeringtorquelimits_nm() const;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* _internal_mutable_maxsteeringtorquelimits_nm();
  public:

  // optional .pb.mf_lsca.config_steer_resist_t.configSteerResist_t resistanceData = 1940;
  bool has_resistancedata() const;
  private:
  bool _internal_has_resistancedata() const;
  public:
  void clear_resistancedata();
  const ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t& resistancedata() const;
  ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* release_resistancedata();
  ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* mutable_resistancedata();
  void set_allocated_resistancedata(::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* resistancedata);
  private:
  const ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t& _internal_resistancedata() const;
  ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* _internal_mutable_resistancedata();
  public:

  // optional .pb.cml.vec2_df_pod.Vec2Df_POD maxSteeringTorqueDelta_Nms = 2200;
  bool has_maxsteeringtorquedelta_nms() const;
  private:
  bool _internal_has_maxsteeringtorquedelta_nms() const;
  public:
  void clear_maxsteeringtorquedelta_nms();
  const ::pb::cml::vec2_df_pod::Vec2Df_POD& maxsteeringtorquedelta_nms() const;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* release_maxsteeringtorquedelta_nms();
  ::pb::cml::vec2_df_pod::Vec2Df_POD* mutable_maxsteeringtorquedelta_nms();
  void set_allocated_maxsteeringtorquedelta_nms(::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringtorquedelta_nms);
  private:
  const ::pb::cml::vec2_df_pod::Vec2Df_POD& _internal_maxsteeringtorquedelta_nms() const;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* _internal_mutable_maxsteeringtorquedelta_nms();
  public:

  // optional .pb.mf_lsca.config_steer_propose_t.configSteerPropose_t proposalData = 3670;
  bool has_proposaldata() const;
  private:
  bool _internal_has_proposaldata() const;
  public:
  void clear_proposaldata();
  const ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t& proposaldata() const;
  ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* release_proposaldata();
  ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* mutable_proposaldata();
  void set_allocated_proposaldata(::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* proposaldata);
  private:
  const ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t& _internal_proposaldata() const;
  ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* _internal_mutable_proposaldata();
  public:

  // optional .pb.cml.vec2_df_pod.Vec2Df_POD maxSteeringAngleDelta_deg = 3987;
  bool has_maxsteeringangledelta_deg() const;
  private:
  bool _internal_has_maxsteeringangledelta_deg() const;
  public:
  void clear_maxsteeringangledelta_deg();
  const ::pb::cml::vec2_df_pod::Vec2Df_POD& maxsteeringangledelta_deg() const;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* release_maxsteeringangledelta_deg();
  ::pb::cml::vec2_df_pod::Vec2Df_POD* mutable_maxsteeringangledelta_deg();
  void set_allocated_maxsteeringangledelta_deg(::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringangledelta_deg);
  private:
  const ::pb::cml::vec2_df_pod::Vec2Df_POD& _internal_maxsteeringangledelta_deg() const;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* _internal_mutable_maxsteeringangledelta_deg();
  public:

  // optional float upperDeactivationSpeedBackwards_ms = 227;
  bool has_upperdeactivationspeedbackwards_ms() const;
  private:
  bool _internal_has_upperdeactivationspeedbackwards_ms() const;
  public:
  void clear_upperdeactivationspeedbackwards_ms();
  float upperdeactivationspeedbackwards_ms() const;
  void set_upperdeactivationspeedbackwards_ms(float value);
  private:
  float _internal_upperdeactivationspeedbackwards_ms() const;
  void _internal_set_upperdeactivationspeedbackwards_ms(float value);
  public:

  // optional float enlargementSide_m = 262;
  bool has_enlargementside_m() const;
  private:
  bool _internal_has_enlargementside_m() const;
  public:
  void clear_enlargementside_m();
  float enlargementside_m() const;
  void set_enlargementside_m(float value);
  private:
  float _internal_enlargementside_m() const;
  void _internal_set_enlargementside_m(float value);
  public:

  // optional float roiTravelledDistOffsetResist_m = 663;
  bool has_roitravelleddistoffsetresist_m() const;
  private:
  bool _internal_has_roitravelleddistoffsetresist_m() const;
  public:
  void clear_roitravelleddistoffsetresist_m();
  float roitravelleddistoffsetresist_m() const;
  void set_roitravelleddistoffsetresist_m(float value);
  private:
  float _internal_roitravelleddistoffsetresist_m() const;
  void _internal_set_roitravelleddistoffsetresist_m(float value);
  public:

  // optional float overrideTime_s = 688;
  bool has_overridetime_s() const;
  private:
  bool _internal_has_overridetime_s() const;
  public:
  void clear_overridetime_s();
  float overridetime_s() const;
  void set_overridetime_s(float value);
  private:
  float _internal_overridetime_s() const;
  void _internal_set_overridetime_s(float value);
  public:

  // optional float roiWidth_s = 707;
  bool has_roiwidth_s() const;
  private:
  bool _internal_has_roiwidth_s() const;
  public:
  void clear_roiwidth_s();
  float roiwidth_s() const;
  void set_roiwidth_s(float value);
  private:
  float _internal_roiwidth_s() const;
  void _internal_set_roiwidth_s(float value);
  public:

  // optional float lowerDeactivationSpeedBackwards_ms = 827;
  bool has_lowerdeactivationspeedbackwards_ms() const;
  private:
  bool _internal_has_lowerdeactivationspeedbackwards_ms() const;
  public:
  void clear_lowerdeactivationspeedbackwards_ms();
  float lowerdeactivationspeedbackwards_ms() const;
  void set_lowerdeactivationspeedbackwards_ms(float value);
  private:
  float _internal_lowerdeactivationspeedbackwards_ms() const;
  void _internal_set_lowerdeactivationspeedbackwards_ms(float value);
  public:

  // optional float lowerDeactivationSpeedForwards_ms = 885;
  bool has_lowerdeactivationspeedforwards_ms() const;
  private:
  bool _internal_has_lowerdeactivationspeedforwards_ms() const;
  public:
  void clear_lowerdeactivationspeedforwards_ms();
  float lowerdeactivationspeedforwards_ms() const;
  void set_lowerdeactivationspeedforwards_ms(float value);
  private:
  float _internal_lowerdeactivationspeedforwards_ms() const;
  void _internal_set_lowerdeactivationspeedforwards_ms(float value);
  public:

  // optional float roiTravelledDistResist_s = 1271;
  bool has_roitravelleddistresist_s() const;
  private:
  bool _internal_has_roitravelleddistresist_s() const;
  public:
  void clear_roitravelleddistresist_s();
  float roitravelleddistresist_s() const;
  void set_roitravelleddistresist_s(float value);
  private:
  float _internal_roitravelleddistresist_s() const;
  void _internal_set_roitravelleddistresist_s(float value);
  public:

  // optional float enlargementRear_m = 1339;
  bool has_enlargementrear_m() const;
  private:
  bool _internal_has_enlargementrear_m() const;
  public:
  void clear_enlargementrear_m();
  float enlargementrear_m() const;
  void set_enlargementrear_m(float value);
  private:
  float _internal_enlargementrear_m() const;
  void _internal_set_enlargementrear_m(float value);
  public:

  // optional float immediateOverrideTorque_Nm = 1533;
  bool has_immediateoverridetorque_nm() const;
  private:
  bool _internal_has_immediateoverridetorque_nm() const;
  public:
  void clear_immediateoverridetorque_nm();
  float immediateoverridetorque_nm() const;
  void set_immediateoverridetorque_nm(float value);
  private:
  float _internal_immediateoverridetorque_nm() const;
  void _internal_set_immediateoverridetorque_nm(float value);
  public:

  // optional float upperDeactivationSpeedForwards_ms = 1789;
  bool has_upperdeactivationspeedforwards_ms() const;
  private:
  bool _internal_has_upperdeactivationspeedforwards_ms() const;
  public:
  void clear_upperdeactivationspeedforwards_ms();
  float upperdeactivationspeedforwards_ms() const;
  void set_upperdeactivationspeedforwards_ms(float value);
  private:
  float _internal_upperdeactivationspeedforwards_ms() const;
  void _internal_set_upperdeactivationspeedforwards_ms(float value);
  public:

  // optional float lowerActivationSpeedForwards_ms = 1858;
  bool has_loweractivationspeedforwards_ms() const;
  private:
  bool _internal_has_loweractivationspeedforwards_ms() const;
  public:
  void clear_loweractivationspeedforwards_ms();
  float loweractivationspeedforwards_ms() const;
  void set_loweractivationspeedforwards_ms(float value);
  private:
  float _internal_loweractivationspeedforwards_ms() const;
  void _internal_set_loweractivationspeedforwards_ms(float value);
  public:

  // optional float rearSteerAngleRatio = 1939;
  bool has_rearsteerangleratio() const;
  private:
  bool _internal_has_rearsteerangleratio() const;
  public:
  void clear_rearsteerangleratio();
  float rearsteerangleratio() const;
  void set_rearsteerangleratio(float value);
  private:
  float _internal_rearsteerangleratio() const;
  void _internal_set_rearsteerangleratio(float value);
  public:

  // optional float roiTravelledDistProp_s = 2008;
  bool has_roitravelleddistprop_s() const;
  private:
  bool _internal_has_roitravelleddistprop_s() const;
  public:
  void clear_roitravelleddistprop_s();
  float roitravelleddistprop_s() const;
  void set_roitravelleddistprop_s(float value);
  private:
  float _internal_roitravelleddistprop_s() const;
  void _internal_set_roitravelleddistprop_s(float value);
  public:

  // optional float roiLength_s = 2236;
  bool has_roilength_s() const;
  private:
  bool _internal_has_roilength_s() const;
  public:
  void clear_roilength_s();
  float roilength_s() const;
  void set_roilength_s(float value);
  private:
  float _internal_roilength_s() const;
  void _internal_set_roilength_s(float value);
  public:

  // optional uint32 minDynamicObjectProbability_perc = 2440;
  bool has_mindynamicobjectprobability_perc() const;
  private:
  bool _internal_has_mindynamicobjectprobability_perc() const;
  public:
  void clear_mindynamicobjectprobability_perc();
  ::PROTOBUF_NAMESPACE_ID::uint32 mindynamicobjectprobability_perc() const;
  void set_mindynamicobjectprobability_perc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mindynamicobjectprobability_perc() const;
  void _internal_set_mindynamicobjectprobability_perc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool checkSeat_nu = 3889;
  bool has_checkseat_nu() const;
  private:
  bool _internal_has_checkseat_nu() const;
  public:
  void clear_checkseat_nu();
  bool checkseat_nu() const;
  void set_checkseat_nu(bool value);
  private:
  bool _internal_checkseat_nu() const;
  void _internal_set_checkseat_nu(bool value);
  public:

  // optional bool torqueInterfaceActive_nu = 1116;
  bool has_torqueinterfaceactive_nu() const;
  private:
  bool _internal_has_torqueinterfaceactive_nu() const;
  public:
  void clear_torqueinterfaceactive_nu();
  bool torqueinterfaceactive_nu() const;
  void set_torqueinterfaceactive_nu(bool value);
  private:
  bool _internal_torqueinterfaceactive_nu() const;
  void _internal_set_torqueinterfaceactive_nu(bool value);
  public:

  // optional bool stopInterventionIfError_nu = 3855;
  bool has_stopinterventioniferror_nu() const;
  private:
  bool _internal_has_stopinterventioniferror_nu() const;
  public:
  void clear_stopinterventioniferror_nu();
  bool stopinterventioniferror_nu() const;
  void set_stopinterventioniferror_nu(bool value);
  private:
  bool _internal_stopinterventioniferror_nu() const;
  void _internal_set_stopinterventioniferror_nu(bool value);
  public:

  // optional bool checkDoors_nu = 2707;
  bool has_checkdoors_nu() const;
  private:
  bool _internal_has_checkdoors_nu() const;
  public:
  void clear_checkdoors_nu();
  bool checkdoors_nu() const;
  void set_checkdoors_nu(bool value);
  private:
  bool _internal_checkdoors_nu() const;
  void _internal_set_checkdoors_nu(bool value);
  public:

  // optional bool checkDriverSeatbelt_nu = 1677;
  bool has_checkdriverseatbelt_nu() const;
  private:
  bool _internal_has_checkdriverseatbelt_nu() const;
  public:
  void clear_checkdriverseatbelt_nu();
  bool checkdriverseatbelt_nu() const;
  void set_checkdriverseatbelt_nu(bool value);
  private:
  bool _internal_checkdriverseatbelt_nu() const;
  void _internal_set_checkdriverseatbelt_nu(bool value);
  public:

  // optional bool checkTrunk_nu = 1989;
  bool has_checktrunk_nu() const;
  private:
  bool _internal_has_checktrunk_nu() const;
  public:
  void clear_checktrunk_nu();
  bool checktrunk_nu() const;
  void set_checktrunk_nu(bool value);
  private:
  bool _internal_checktrunk_nu() const;
  void _internal_set_checktrunk_nu(bool value);
  public:

  // optional float lowerActivationSpeedBackwards_ms = 2600;
  bool has_loweractivationspeedbackwards_ms() const;
  private:
  bool _internal_has_loweractivationspeedbackwards_ms() const;
  public:
  void clear_loweractivationspeedbackwards_ms();
  float loweractivationspeedbackwards_ms() const;
  void set_loweractivationspeedbackwards_ms(float value);
  private:
  float _internal_loweractivationspeedbackwards_ms() const;
  void _internal_set_loweractivationspeedbackwards_ms(float value);
  public:

  // optional float upperActivationSpeedBackwards_ms = 2668;
  bool has_upperactivationspeedbackwards_ms() const;
  private:
  bool _internal_has_upperactivationspeedbackwards_ms() const;
  public:
  void clear_upperactivationspeedbackwards_ms();
  float upperactivationspeedbackwards_ms() const;
  void set_upperactivationspeedbackwards_ms(float value);
  private:
  float _internal_upperactivationspeedbackwards_ms() const;
  void _internal_set_upperactivationspeedbackwards_ms(float value);
  public:

  // optional float roiTravelledDistOffsetProp_m = 2806;
  bool has_roitravelleddistoffsetprop_m() const;
  private:
  bool _internal_has_roitravelleddistoffsetprop_m() const;
  public:
  void clear_roitravelleddistoffsetprop_m();
  float roitravelleddistoffsetprop_m() const;
  void set_roitravelleddistoffsetprop_m(float value);
  private:
  float _internal_roitravelleddistoffsetprop_m() const;
  void _internal_set_roitravelleddistoffsetprop_m(float value);
  public:

  // optional float roiLengthOffset_m = 3175;
  bool has_roilengthoffset_m() const;
  private:
  bool _internal_has_roilengthoffset_m() const;
  public:
  void clear_roilengthoffset_m();
  float roilengthoffset_m() const;
  void set_roilengthoffset_m(float value);
  private:
  float _internal_roilengthoffset_m() const;
  void _internal_set_roilengthoffset_m(float value);
  public:

  // optional uint32 minStaticObjectProbability_perc = 3245;
  bool has_minstaticobjectprobability_perc() const;
  private:
  bool _internal_has_minstaticobjectprobability_perc() const;
  public:
  void clear_minstaticobjectprobability_perc();
  ::PROTOBUF_NAMESPACE_ID::uint32 minstaticobjectprobability_perc() const;
  void set_minstaticobjectprobability_perc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_minstaticobjectprobability_perc() const;
  void _internal_set_minstaticobjectprobability_perc(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float timeBasedOverrideTorque_Nm = 3376;
  bool has_timebasedoverridetorque_nm() const;
  private:
  bool _internal_has_timebasedoverridetorque_nm() const;
  public:
  void clear_timebasedoverridetorque_nm();
  float timebasedoverridetorque_nm() const;
  void set_timebasedoverridetorque_nm(float value);
  private:
  float _internal_timebasedoverridetorque_nm() const;
  void _internal_set_timebasedoverridetorque_nm(float value);
  public:

  // optional float roiWidthOffset_m = 3478;
  bool has_roiwidthoffset_m() const;
  private:
  bool _internal_has_roiwidthoffset_m() const;
  public:
  void clear_roiwidthoffset_m();
  float roiwidthoffset_m() const;
  void set_roiwidthoffset_m(float value);
  private:
  float _internal_roiwidthoffset_m() const;
  void _internal_set_roiwidthoffset_m(float value);
  public:

  // optional float enlargementFront_m = 3610;
  bool has_enlargementfront_m() const;
  private:
  bool _internal_has_enlargementfront_m() const;
  public:
  void clear_enlargementfront_m();
  float enlargementfront_m() const;
  void set_enlargementfront_m(float value);
  private:
  float _internal_enlargementfront_m() const;
  void _internal_set_enlargementfront_m(float value);
  public:

  // optional float upperActivationSpeedForwards_ms = 3994;
  bool has_upperactivationspeedforwards_ms() const;
  private:
  bool _internal_has_upperactivationspeedforwards_ms() const;
  public:
  void clear_upperactivationspeedforwards_ms();
  float upperactivationspeedforwards_ms() const;
  void set_upperactivationspeedforwards_ms(float value);
  private:
  float _internal_upperactivationspeedforwards_ms() const;
  void _internal_set_upperactivationspeedforwards_ms(float value);
  public:

  // optional float overrideDistance_m = 3439220;
  bool has_overridedistance_m() const;
  private:
  bool _internal_has_overridedistance_m() const;
  public:
  void clear_overridedistance_m();
  float overridedistance_m() const;
  void set_overridedistance_m(float value);
  private:
  float _internal_overridedistance_m() const;
  void _internal_set_overridedistance_m(float value);
  public:

  // @@protoc_insertion_point(class_scope:pb.mf_lsca.config_steer_t.configSteer_t)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringanglelimits_deg_;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringtorquelimits_nm_;
  ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* resistancedata_;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringtorquedelta_nms_;
  ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* proposaldata_;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringangledelta_deg_;
  float upperdeactivationspeedbackwards_ms_;
  float enlargementside_m_;
  float roitravelleddistoffsetresist_m_;
  float overridetime_s_;
  float roiwidth_s_;
  float lowerdeactivationspeedbackwards_ms_;
  float lowerdeactivationspeedforwards_ms_;
  float roitravelleddistresist_s_;
  float enlargementrear_m_;
  float immediateoverridetorque_nm_;
  float upperdeactivationspeedforwards_ms_;
  float loweractivationspeedforwards_ms_;
  float rearsteerangleratio_;
  float roitravelleddistprop_s_;
  float roilength_s_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mindynamicobjectprobability_perc_;
  bool checkseat_nu_;
  bool torqueinterfaceactive_nu_;
  bool stopinterventioniferror_nu_;
  bool checkdoors_nu_;
  bool checkdriverseatbelt_nu_;
  bool checktrunk_nu_;
  float loweractivationspeedbackwards_ms_;
  float upperactivationspeedbackwards_ms_;
  float roitravelleddistoffsetprop_m_;
  float roilengthoffset_m_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minstaticobjectprobability_perc_;
  float timebasedoverridetorque_nm_;
  float roiwidthoffset_m_;
  float enlargementfront_m_;
  float upperactivationspeedforwards_ms_;
  float overridedistance_m_;
  friend struct ::TableStruct_mf_5flsca_2fconfig_5fsteer_5ft_2eproto;
};
// -------------------------------------------------------------------

class configSteer_t_array_port :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.mf_lsca.config_steer_t.configSteer_t_array_port) */ {
 public:
  configSteer_t_array_port();
  virtual ~configSteer_t_array_port();

  configSteer_t_array_port(const configSteer_t_array_port& from);
  configSteer_t_array_port(configSteer_t_array_port&& from) noexcept
    : configSteer_t_array_port() {
    *this = ::std::move(from);
  }

  inline configSteer_t_array_port& operator=(const configSteer_t_array_port& from) {
    CopyFrom(from);
    return *this;
  }
  inline configSteer_t_array_port& operator=(configSteer_t_array_port&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const configSteer_t_array_port& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const configSteer_t_array_port* internal_default_instance() {
    return reinterpret_cast<const configSteer_t_array_port*>(
               &_configSteer_t_array_port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(configSteer_t_array_port& a, configSteer_t_array_port& b) {
    a.Swap(&b);
  }
  inline void Swap(configSteer_t_array_port* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline configSteer_t_array_port* New() const final {
    return CreateMaybeMessage<configSteer_t_array_port>(nullptr);
  }

  configSteer_t_array_port* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<configSteer_t_array_port>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const configSteer_t_array_port& from);
  void MergeFrom(const configSteer_t_array_port& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(configSteer_t_array_port* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.mf_lsca.config_steer_t.configSteer_t_array_port";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mf_5flsca_2fconfig_5fsteer_5ft_2eproto);
    return ::descriptor_table_mf_5flsca_2fconfig_5fsteer_5ft_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3770,
  };
  // repeated .pb.mf_lsca.config_steer_t.configSteer_t data = 3770;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::pb::mf_lsca::config_steer_t::configSteer_t* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::mf_lsca::config_steer_t::configSteer_t >*
      mutable_data();
  private:
  const ::pb::mf_lsca::config_steer_t::configSteer_t& _internal_data(int index) const;
  ::pb::mf_lsca::config_steer_t::configSteer_t* _internal_add_data();
  public:
  const ::pb::mf_lsca::config_steer_t::configSteer_t& data(int index) const;
  ::pb::mf_lsca::config_steer_t::configSteer_t* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::mf_lsca::config_steer_t::configSteer_t >&
      data() const;

  // @@protoc_insertion_point(class_scope:pb.mf_lsca.config_steer_t.configSteer_t_array_port)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::mf_lsca::config_steer_t::configSteer_t > data_;
  friend struct ::TableStruct_mf_5flsca_2fconfig_5fsteer_5ft_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// configSteer_t

// optional .pb.mf_lsca.config_steer_propose_t.configSteerPropose_t proposalData = 3670;
inline bool configSteer_t::_internal_has_proposaldata() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || proposaldata_ != nullptr);
  return value;
}
inline bool configSteer_t::has_proposaldata() const {
  return _internal_has_proposaldata();
}
inline const ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t& configSteer_t::_internal_proposaldata() const {
  const ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* p = proposaldata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t*>(
      &::pb::mf_lsca::config_steer_propose_t::_configSteerPropose_t_default_instance_);
}
inline const ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t& configSteer_t::proposaldata() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.proposalData)
  return _internal_proposaldata();
}
inline ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* configSteer_t::release_proposaldata() {
  // @@protoc_insertion_point(field_release:pb.mf_lsca.config_steer_t.configSteer_t.proposalData)
  _has_bits_[0] &= ~0x00000010u;
  ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* temp = proposaldata_;
  proposaldata_ = nullptr;
  return temp;
}
inline ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* configSteer_t::_internal_mutable_proposaldata() {
  _has_bits_[0] |= 0x00000010u;
  if (proposaldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t>(GetArenaNoVirtual());
    proposaldata_ = p;
  }
  return proposaldata_;
}
inline ::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* configSteer_t::mutable_proposaldata() {
  // @@protoc_insertion_point(field_mutable:pb.mf_lsca.config_steer_t.configSteer_t.proposalData)
  return _internal_mutable_proposaldata();
}
inline void configSteer_t::set_allocated_proposaldata(::pb::mf_lsca::config_steer_propose_t::configSteerPropose_t* proposaldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposaldata_);
  }
  if (proposaldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      proposaldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposaldata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  proposaldata_ = proposaldata;
  // @@protoc_insertion_point(field_set_allocated:pb.mf_lsca.config_steer_t.configSteer_t.proposalData)
}

// optional .pb.cml.vec2_df_pod.Vec2Df_POD maxSteeringAngleLimits_deg = 336;
inline bool configSteer_t::_internal_has_maxsteeringanglelimits_deg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || maxsteeringanglelimits_deg_ != nullptr);
  return value;
}
inline bool configSteer_t::has_maxsteeringanglelimits_deg() const {
  return _internal_has_maxsteeringanglelimits_deg();
}
inline const ::pb::cml::vec2_df_pod::Vec2Df_POD& configSteer_t::_internal_maxsteeringanglelimits_deg() const {
  const ::pb::cml::vec2_df_pod::Vec2Df_POD* p = maxsteeringanglelimits_deg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::cml::vec2_df_pod::Vec2Df_POD*>(
      &::pb::cml::vec2_df_pod::_Vec2Df_POD_default_instance_);
}
inline const ::pb::cml::vec2_df_pod::Vec2Df_POD& configSteer_t::maxsteeringanglelimits_deg() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringAngleLimits_deg)
  return _internal_maxsteeringanglelimits_deg();
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::release_maxsteeringanglelimits_deg() {
  // @@protoc_insertion_point(field_release:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringAngleLimits_deg)
  _has_bits_[0] &= ~0x00000001u;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* temp = maxsteeringanglelimits_deg_;
  maxsteeringanglelimits_deg_ = nullptr;
  return temp;
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::_internal_mutable_maxsteeringanglelimits_deg() {
  _has_bits_[0] |= 0x00000001u;
  if (maxsteeringanglelimits_deg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::cml::vec2_df_pod::Vec2Df_POD>(GetArenaNoVirtual());
    maxsteeringanglelimits_deg_ = p;
  }
  return maxsteeringanglelimits_deg_;
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::mutable_maxsteeringanglelimits_deg() {
  // @@protoc_insertion_point(field_mutable:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringAngleLimits_deg)
  return _internal_mutable_maxsteeringanglelimits_deg();
}
inline void configSteer_t::set_allocated_maxsteeringanglelimits_deg(::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringanglelimits_deg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxsteeringanglelimits_deg_);
  }
  if (maxsteeringanglelimits_deg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      maxsteeringanglelimits_deg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxsteeringanglelimits_deg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  maxsteeringanglelimits_deg_ = maxsteeringanglelimits_deg;
  // @@protoc_insertion_point(field_set_allocated:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringAngleLimits_deg)
}

// optional .pb.cml.vec2_df_pod.Vec2Df_POD maxSteeringAngleDelta_deg = 3987;
inline bool configSteer_t::_internal_has_maxsteeringangledelta_deg() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || maxsteeringangledelta_deg_ != nullptr);
  return value;
}
inline bool configSteer_t::has_maxsteeringangledelta_deg() const {
  return _internal_has_maxsteeringangledelta_deg();
}
inline const ::pb::cml::vec2_df_pod::Vec2Df_POD& configSteer_t::_internal_maxsteeringangledelta_deg() const {
  const ::pb::cml::vec2_df_pod::Vec2Df_POD* p = maxsteeringangledelta_deg_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::cml::vec2_df_pod::Vec2Df_POD*>(
      &::pb::cml::vec2_df_pod::_Vec2Df_POD_default_instance_);
}
inline const ::pb::cml::vec2_df_pod::Vec2Df_POD& configSteer_t::maxsteeringangledelta_deg() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringAngleDelta_deg)
  return _internal_maxsteeringangledelta_deg();
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::release_maxsteeringangledelta_deg() {
  // @@protoc_insertion_point(field_release:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringAngleDelta_deg)
  _has_bits_[0] &= ~0x00000020u;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* temp = maxsteeringangledelta_deg_;
  maxsteeringangledelta_deg_ = nullptr;
  return temp;
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::_internal_mutable_maxsteeringangledelta_deg() {
  _has_bits_[0] |= 0x00000020u;
  if (maxsteeringangledelta_deg_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::cml::vec2_df_pod::Vec2Df_POD>(GetArenaNoVirtual());
    maxsteeringangledelta_deg_ = p;
  }
  return maxsteeringangledelta_deg_;
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::mutable_maxsteeringangledelta_deg() {
  // @@protoc_insertion_point(field_mutable:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringAngleDelta_deg)
  return _internal_mutable_maxsteeringangledelta_deg();
}
inline void configSteer_t::set_allocated_maxsteeringangledelta_deg(::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringangledelta_deg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxsteeringangledelta_deg_);
  }
  if (maxsteeringangledelta_deg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      maxsteeringangledelta_deg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxsteeringangledelta_deg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  maxsteeringangledelta_deg_ = maxsteeringangledelta_deg;
  // @@protoc_insertion_point(field_set_allocated:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringAngleDelta_deg)
}

// optional .pb.cml.vec2_df_pod.Vec2Df_POD maxSteeringTorqueLimits_Nm = 1822;
inline bool configSteer_t::_internal_has_maxsteeringtorquelimits_nm() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || maxsteeringtorquelimits_nm_ != nullptr);
  return value;
}
inline bool configSteer_t::has_maxsteeringtorquelimits_nm() const {
  return _internal_has_maxsteeringtorquelimits_nm();
}
inline const ::pb::cml::vec2_df_pod::Vec2Df_POD& configSteer_t::_internal_maxsteeringtorquelimits_nm() const {
  const ::pb::cml::vec2_df_pod::Vec2Df_POD* p = maxsteeringtorquelimits_nm_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::cml::vec2_df_pod::Vec2Df_POD*>(
      &::pb::cml::vec2_df_pod::_Vec2Df_POD_default_instance_);
}
inline const ::pb::cml::vec2_df_pod::Vec2Df_POD& configSteer_t::maxsteeringtorquelimits_nm() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringTorqueLimits_Nm)
  return _internal_maxsteeringtorquelimits_nm();
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::release_maxsteeringtorquelimits_nm() {
  // @@protoc_insertion_point(field_release:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringTorqueLimits_Nm)
  _has_bits_[0] &= ~0x00000002u;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* temp = maxsteeringtorquelimits_nm_;
  maxsteeringtorquelimits_nm_ = nullptr;
  return temp;
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::_internal_mutable_maxsteeringtorquelimits_nm() {
  _has_bits_[0] |= 0x00000002u;
  if (maxsteeringtorquelimits_nm_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::cml::vec2_df_pod::Vec2Df_POD>(GetArenaNoVirtual());
    maxsteeringtorquelimits_nm_ = p;
  }
  return maxsteeringtorquelimits_nm_;
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::mutable_maxsteeringtorquelimits_nm() {
  // @@protoc_insertion_point(field_mutable:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringTorqueLimits_Nm)
  return _internal_mutable_maxsteeringtorquelimits_nm();
}
inline void configSteer_t::set_allocated_maxsteeringtorquelimits_nm(::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringtorquelimits_nm) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxsteeringtorquelimits_nm_);
  }
  if (maxsteeringtorquelimits_nm) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      maxsteeringtorquelimits_nm = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxsteeringtorquelimits_nm, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  maxsteeringtorquelimits_nm_ = maxsteeringtorquelimits_nm;
  // @@protoc_insertion_point(field_set_allocated:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringTorqueLimits_Nm)
}

// optional .pb.cml.vec2_df_pod.Vec2Df_POD maxSteeringTorqueDelta_Nms = 2200;
inline bool configSteer_t::_internal_has_maxsteeringtorquedelta_nms() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || maxsteeringtorquedelta_nms_ != nullptr);
  return value;
}
inline bool configSteer_t::has_maxsteeringtorquedelta_nms() const {
  return _internal_has_maxsteeringtorquedelta_nms();
}
inline const ::pb::cml::vec2_df_pod::Vec2Df_POD& configSteer_t::_internal_maxsteeringtorquedelta_nms() const {
  const ::pb::cml::vec2_df_pod::Vec2Df_POD* p = maxsteeringtorquedelta_nms_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::cml::vec2_df_pod::Vec2Df_POD*>(
      &::pb::cml::vec2_df_pod::_Vec2Df_POD_default_instance_);
}
inline const ::pb::cml::vec2_df_pod::Vec2Df_POD& configSteer_t::maxsteeringtorquedelta_nms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringTorqueDelta_Nms)
  return _internal_maxsteeringtorquedelta_nms();
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::release_maxsteeringtorquedelta_nms() {
  // @@protoc_insertion_point(field_release:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringTorqueDelta_Nms)
  _has_bits_[0] &= ~0x00000008u;
  ::pb::cml::vec2_df_pod::Vec2Df_POD* temp = maxsteeringtorquedelta_nms_;
  maxsteeringtorquedelta_nms_ = nullptr;
  return temp;
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::_internal_mutable_maxsteeringtorquedelta_nms() {
  _has_bits_[0] |= 0x00000008u;
  if (maxsteeringtorquedelta_nms_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::cml::vec2_df_pod::Vec2Df_POD>(GetArenaNoVirtual());
    maxsteeringtorquedelta_nms_ = p;
  }
  return maxsteeringtorquedelta_nms_;
}
inline ::pb::cml::vec2_df_pod::Vec2Df_POD* configSteer_t::mutable_maxsteeringtorquedelta_nms() {
  // @@protoc_insertion_point(field_mutable:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringTorqueDelta_Nms)
  return _internal_mutable_maxsteeringtorquedelta_nms();
}
inline void configSteer_t::set_allocated_maxsteeringtorquedelta_nms(::pb::cml::vec2_df_pod::Vec2Df_POD* maxsteeringtorquedelta_nms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxsteeringtorquedelta_nms_);
  }
  if (maxsteeringtorquedelta_nms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      maxsteeringtorquedelta_nms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxsteeringtorquedelta_nms, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  maxsteeringtorquedelta_nms_ = maxsteeringtorquedelta_nms;
  // @@protoc_insertion_point(field_set_allocated:pb.mf_lsca.config_steer_t.configSteer_t.maxSteeringTorqueDelta_Nms)
}

// optional .pb.mf_lsca.config_steer_resist_t.configSteerResist_t resistanceData = 1940;
inline bool configSteer_t::_internal_has_resistancedata() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || resistancedata_ != nullptr);
  return value;
}
inline bool configSteer_t::has_resistancedata() const {
  return _internal_has_resistancedata();
}
inline const ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t& configSteer_t::_internal_resistancedata() const {
  const ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* p = resistancedata_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t*>(
      &::pb::mf_lsca::config_steer_resist_t::_configSteerResist_t_default_instance_);
}
inline const ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t& configSteer_t::resistancedata() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.resistanceData)
  return _internal_resistancedata();
}
inline ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* configSteer_t::release_resistancedata() {
  // @@protoc_insertion_point(field_release:pb.mf_lsca.config_steer_t.configSteer_t.resistanceData)
  _has_bits_[0] &= ~0x00000004u;
  ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* temp = resistancedata_;
  resistancedata_ = nullptr;
  return temp;
}
inline ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* configSteer_t::_internal_mutable_resistancedata() {
  _has_bits_[0] |= 0x00000004u;
  if (resistancedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::mf_lsca::config_steer_resist_t::configSteerResist_t>(GetArenaNoVirtual());
    resistancedata_ = p;
  }
  return resistancedata_;
}
inline ::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* configSteer_t::mutable_resistancedata() {
  // @@protoc_insertion_point(field_mutable:pb.mf_lsca.config_steer_t.configSteer_t.resistanceData)
  return _internal_mutable_resistancedata();
}
inline void configSteer_t::set_allocated_resistancedata(::pb::mf_lsca::config_steer_resist_t::configSteerResist_t* resistancedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(resistancedata_);
  }
  if (resistancedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      resistancedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resistancedata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  resistancedata_ = resistancedata;
  // @@protoc_insertion_point(field_set_allocated:pb.mf_lsca.config_steer_t.configSteer_t.resistanceData)
}

// optional float roiLengthOffset_m = 3175;
inline bool configSteer_t::_internal_has_roilengthoffset_m() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool configSteer_t::has_roilengthoffset_m() const {
  return _internal_has_roilengthoffset_m();
}
inline void configSteer_t::clear_roilengthoffset_m() {
  roilengthoffset_m_ = 0;
  _has_bits_[0] &= ~0x80000000u;
}
inline float configSteer_t::_internal_roilengthoffset_m() const {
  return roilengthoffset_m_;
}
inline float configSteer_t::roilengthoffset_m() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.roiLengthOffset_m)
  return _internal_roilengthoffset_m();
}
inline void configSteer_t::_internal_set_roilengthoffset_m(float value) {
  _has_bits_[0] |= 0x80000000u;
  roilengthoffset_m_ = value;
}
inline void configSteer_t::set_roilengthoffset_m(float value) {
  _internal_set_roilengthoffset_m(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.roiLengthOffset_m)
}

// optional float roiLength_s = 2236;
inline bool configSteer_t::_internal_has_roilength_s() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool configSteer_t::has_roilength_s() const {
  return _internal_has_roilength_s();
}
inline void configSteer_t::clear_roilength_s() {
  roilength_s_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline float configSteer_t::_internal_roilength_s() const {
  return roilength_s_;
}
inline float configSteer_t::roilength_s() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.roiLength_s)
  return _internal_roilength_s();
}
inline void configSteer_t::_internal_set_roilength_s(float value) {
  _has_bits_[0] |= 0x00100000u;
  roilength_s_ = value;
}
inline void configSteer_t::set_roilength_s(float value) {
  _internal_set_roilength_s(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.roiLength_s)
}

// optional float roiWidthOffset_m = 3478;
inline bool configSteer_t::_internal_has_roiwidthoffset_m() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool configSteer_t::has_roiwidthoffset_m() const {
  return _internal_has_roiwidthoffset_m();
}
inline void configSteer_t::clear_roiwidthoffset_m() {
  roiwidthoffset_m_ = 0;
  _has_bits_[1] &= ~0x00000004u;
}
inline float configSteer_t::_internal_roiwidthoffset_m() const {
  return roiwidthoffset_m_;
}
inline float configSteer_t::roiwidthoffset_m() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.roiWidthOffset_m)
  return _internal_roiwidthoffset_m();
}
inline void configSteer_t::_internal_set_roiwidthoffset_m(float value) {
  _has_bits_[1] |= 0x00000004u;
  roiwidthoffset_m_ = value;
}
inline void configSteer_t::set_roiwidthoffset_m(float value) {
  _internal_set_roiwidthoffset_m(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.roiWidthOffset_m)
}

// optional float roiWidth_s = 707;
inline bool configSteer_t::_internal_has_roiwidth_s() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool configSteer_t::has_roiwidth_s() const {
  return _internal_has_roiwidth_s();
}
inline void configSteer_t::clear_roiwidth_s() {
  roiwidth_s_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float configSteer_t::_internal_roiwidth_s() const {
  return roiwidth_s_;
}
inline float configSteer_t::roiwidth_s() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.roiWidth_s)
  return _internal_roiwidth_s();
}
inline void configSteer_t::_internal_set_roiwidth_s(float value) {
  _has_bits_[0] |= 0x00000400u;
  roiwidth_s_ = value;
}
inline void configSteer_t::set_roiwidth_s(float value) {
  _internal_set_roiwidth_s(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.roiWidth_s)
}

// optional float roiTravelledDistOffsetProp_m = 2806;
inline bool configSteer_t::_internal_has_roitravelleddistoffsetprop_m() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool configSteer_t::has_roitravelleddistoffsetprop_m() const {
  return _internal_has_roitravelleddistoffsetprop_m();
}
inline void configSteer_t::clear_roitravelleddistoffsetprop_m() {
  roitravelleddistoffsetprop_m_ = 0;
  _has_bits_[0] &= ~0x40000000u;
}
inline float configSteer_t::_internal_roitravelleddistoffsetprop_m() const {
  return roitravelleddistoffsetprop_m_;
}
inline float configSteer_t::roitravelleddistoffsetprop_m() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.roiTravelledDistOffsetProp_m)
  return _internal_roitravelleddistoffsetprop_m();
}
inline void configSteer_t::_internal_set_roitravelleddistoffsetprop_m(float value) {
  _has_bits_[0] |= 0x40000000u;
  roitravelleddistoffsetprop_m_ = value;
}
inline void configSteer_t::set_roitravelleddistoffsetprop_m(float value) {
  _internal_set_roitravelleddistoffsetprop_m(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.roiTravelledDistOffsetProp_m)
}

// optional float roiTravelledDistOffsetResist_m = 663;
inline bool configSteer_t::_internal_has_roitravelleddistoffsetresist_m() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool configSteer_t::has_roitravelleddistoffsetresist_m() const {
  return _internal_has_roitravelleddistoffsetresist_m();
}
inline void configSteer_t::clear_roitravelleddistoffsetresist_m() {
  roitravelleddistoffsetresist_m_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float configSteer_t::_internal_roitravelleddistoffsetresist_m() const {
  return roitravelleddistoffsetresist_m_;
}
inline float configSteer_t::roitravelleddistoffsetresist_m() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.roiTravelledDistOffsetResist_m)
  return _internal_roitravelleddistoffsetresist_m();
}
inline void configSteer_t::_internal_set_roitravelleddistoffsetresist_m(float value) {
  _has_bits_[0] |= 0x00000100u;
  roitravelleddistoffsetresist_m_ = value;
}
inline void configSteer_t::set_roitravelleddistoffsetresist_m(float value) {
  _internal_set_roitravelleddistoffsetresist_m(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.roiTravelledDistOffsetResist_m)
}

// optional float roiTravelledDistProp_s = 2008;
inline bool configSteer_t::_internal_has_roitravelleddistprop_s() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool configSteer_t::has_roitravelleddistprop_s() const {
  return _internal_has_roitravelleddistprop_s();
}
inline void configSteer_t::clear_roitravelleddistprop_s() {
  roitravelleddistprop_s_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline float configSteer_t::_internal_roitravelleddistprop_s() const {
  return roitravelleddistprop_s_;
}
inline float configSteer_t::roitravelleddistprop_s() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.roiTravelledDistProp_s)
  return _internal_roitravelleddistprop_s();
}
inline void configSteer_t::_internal_set_roitravelleddistprop_s(float value) {
  _has_bits_[0] |= 0x00080000u;
  roitravelleddistprop_s_ = value;
}
inline void configSteer_t::set_roitravelleddistprop_s(float value) {
  _internal_set_roitravelleddistprop_s(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.roiTravelledDistProp_s)
}

// optional float roiTravelledDistResist_s = 1271;
inline bool configSteer_t::_internal_has_roitravelleddistresist_s() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool configSteer_t::has_roitravelleddistresist_s() const {
  return _internal_has_roitravelleddistresist_s();
}
inline void configSteer_t::clear_roitravelleddistresist_s() {
  roitravelleddistresist_s_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float configSteer_t::_internal_roitravelleddistresist_s() const {
  return roitravelleddistresist_s_;
}
inline float configSteer_t::roitravelleddistresist_s() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.roiTravelledDistResist_s)
  return _internal_roitravelleddistresist_s();
}
inline void configSteer_t::_internal_set_roitravelleddistresist_s(float value) {
  _has_bits_[0] |= 0x00002000u;
  roitravelleddistresist_s_ = value;
}
inline void configSteer_t::set_roitravelleddistresist_s(float value) {
  _internal_set_roitravelleddistresist_s(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.roiTravelledDistResist_s)
}

// optional float enlargementFront_m = 3610;
inline bool configSteer_t::_internal_has_enlargementfront_m() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool configSteer_t::has_enlargementfront_m() const {
  return _internal_has_enlargementfront_m();
}
inline void configSteer_t::clear_enlargementfront_m() {
  enlargementfront_m_ = 0;
  _has_bits_[1] &= ~0x00000008u;
}
inline float configSteer_t::_internal_enlargementfront_m() const {
  return enlargementfront_m_;
}
inline float configSteer_t::enlargementfront_m() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.enlargementFront_m)
  return _internal_enlargementfront_m();
}
inline void configSteer_t::_internal_set_enlargementfront_m(float value) {
  _has_bits_[1] |= 0x00000008u;
  enlargementfront_m_ = value;
}
inline void configSteer_t::set_enlargementfront_m(float value) {
  _internal_set_enlargementfront_m(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.enlargementFront_m)
}

// optional float enlargementRear_m = 1339;
inline bool configSteer_t::_internal_has_enlargementrear_m() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool configSteer_t::has_enlargementrear_m() const {
  return _internal_has_enlargementrear_m();
}
inline void configSteer_t::clear_enlargementrear_m() {
  enlargementrear_m_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline float configSteer_t::_internal_enlargementrear_m() const {
  return enlargementrear_m_;
}
inline float configSteer_t::enlargementrear_m() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.enlargementRear_m)
  return _internal_enlargementrear_m();
}
inline void configSteer_t::_internal_set_enlargementrear_m(float value) {
  _has_bits_[0] |= 0x00004000u;
  enlargementrear_m_ = value;
}
inline void configSteer_t::set_enlargementrear_m(float value) {
  _internal_set_enlargementrear_m(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.enlargementRear_m)
}

// optional float enlargementSide_m = 262;
inline bool configSteer_t::_internal_has_enlargementside_m() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool configSteer_t::has_enlargementside_m() const {
  return _internal_has_enlargementside_m();
}
inline void configSteer_t::clear_enlargementside_m() {
  enlargementside_m_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float configSteer_t::_internal_enlargementside_m() const {
  return enlargementside_m_;
}
inline float configSteer_t::enlargementside_m() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.enlargementSide_m)
  return _internal_enlargementside_m();
}
inline void configSteer_t::_internal_set_enlargementside_m(float value) {
  _has_bits_[0] |= 0x00000080u;
  enlargementside_m_ = value;
}
inline void configSteer_t::set_enlargementside_m(float value) {
  _internal_set_enlargementside_m(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.enlargementSide_m)
}

// optional float immediateOverrideTorque_Nm = 1533;
inline bool configSteer_t::_internal_has_immediateoverridetorque_nm() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool configSteer_t::has_immediateoverridetorque_nm() const {
  return _internal_has_immediateoverridetorque_nm();
}
inline void configSteer_t::clear_immediateoverridetorque_nm() {
  immediateoverridetorque_nm_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float configSteer_t::_internal_immediateoverridetorque_nm() const {
  return immediateoverridetorque_nm_;
}
inline float configSteer_t::immediateoverridetorque_nm() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.immediateOverrideTorque_Nm)
  return _internal_immediateoverridetorque_nm();
}
inline void configSteer_t::_internal_set_immediateoverridetorque_nm(float value) {
  _has_bits_[0] |= 0x00008000u;
  immediateoverridetorque_nm_ = value;
}
inline void configSteer_t::set_immediateoverridetorque_nm(float value) {
  _internal_set_immediateoverridetorque_nm(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.immediateOverrideTorque_Nm)
}

// optional float timeBasedOverrideTorque_Nm = 3376;
inline bool configSteer_t::_internal_has_timebasedoverridetorque_nm() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool configSteer_t::has_timebasedoverridetorque_nm() const {
  return _internal_has_timebasedoverridetorque_nm();
}
inline void configSteer_t::clear_timebasedoverridetorque_nm() {
  timebasedoverridetorque_nm_ = 0;
  _has_bits_[1] &= ~0x00000002u;
}
inline float configSteer_t::_internal_timebasedoverridetorque_nm() const {
  return timebasedoverridetorque_nm_;
}
inline float configSteer_t::timebasedoverridetorque_nm() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.timeBasedOverrideTorque_Nm)
  return _internal_timebasedoverridetorque_nm();
}
inline void configSteer_t::_internal_set_timebasedoverridetorque_nm(float value) {
  _has_bits_[1] |= 0x00000002u;
  timebasedoverridetorque_nm_ = value;
}
inline void configSteer_t::set_timebasedoverridetorque_nm(float value) {
  _internal_set_timebasedoverridetorque_nm(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.timeBasedOverrideTorque_Nm)
}

// optional float overrideTime_s = 688;
inline bool configSteer_t::_internal_has_overridetime_s() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool configSteer_t::has_overridetime_s() const {
  return _internal_has_overridetime_s();
}
inline void configSteer_t::clear_overridetime_s() {
  overridetime_s_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float configSteer_t::_internal_overridetime_s() const {
  return overridetime_s_;
}
inline float configSteer_t::overridetime_s() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.overrideTime_s)
  return _internal_overridetime_s();
}
inline void configSteer_t::_internal_set_overridetime_s(float value) {
  _has_bits_[0] |= 0x00000200u;
  overridetime_s_ = value;
}
inline void configSteer_t::set_overridetime_s(float value) {
  _internal_set_overridetime_s(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.overrideTime_s)
}

// optional float overrideDistance_m = 3439220;
inline bool configSteer_t::_internal_has_overridedistance_m() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool configSteer_t::has_overridedistance_m() const {
  return _internal_has_overridedistance_m();
}
inline void configSteer_t::clear_overridedistance_m() {
  overridedistance_m_ = 0;
  _has_bits_[1] &= ~0x00000020u;
}
inline float configSteer_t::_internal_overridedistance_m() const {
  return overridedistance_m_;
}
inline float configSteer_t::overridedistance_m() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.overrideDistance_m)
  return _internal_overridedistance_m();
}
inline void configSteer_t::_internal_set_overridedistance_m(float value) {
  _has_bits_[1] |= 0x00000020u;
  overridedistance_m_ = value;
}
inline void configSteer_t::set_overridedistance_m(float value) {
  _internal_set_overridedistance_m(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.overrideDistance_m)
}

// optional float lowerActivationSpeedForwards_ms = 1858;
inline bool configSteer_t::_internal_has_loweractivationspeedforwards_ms() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool configSteer_t::has_loweractivationspeedforwards_ms() const {
  return _internal_has_loweractivationspeedforwards_ms();
}
inline void configSteer_t::clear_loweractivationspeedforwards_ms() {
  loweractivationspeedforwards_ms_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline float configSteer_t::_internal_loweractivationspeedforwards_ms() const {
  return loweractivationspeedforwards_ms_;
}
inline float configSteer_t::loweractivationspeedforwards_ms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.lowerActivationSpeedForwards_ms)
  return _internal_loweractivationspeedforwards_ms();
}
inline void configSteer_t::_internal_set_loweractivationspeedforwards_ms(float value) {
  _has_bits_[0] |= 0x00020000u;
  loweractivationspeedforwards_ms_ = value;
}
inline void configSteer_t::set_loweractivationspeedforwards_ms(float value) {
  _internal_set_loweractivationspeedforwards_ms(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.lowerActivationSpeedForwards_ms)
}

// optional float upperActivationSpeedForwards_ms = 3994;
inline bool configSteer_t::_internal_has_upperactivationspeedforwards_ms() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool configSteer_t::has_upperactivationspeedforwards_ms() const {
  return _internal_has_upperactivationspeedforwards_ms();
}
inline void configSteer_t::clear_upperactivationspeedforwards_ms() {
  upperactivationspeedforwards_ms_ = 0;
  _has_bits_[1] &= ~0x00000010u;
}
inline float configSteer_t::_internal_upperactivationspeedforwards_ms() const {
  return upperactivationspeedforwards_ms_;
}
inline float configSteer_t::upperactivationspeedforwards_ms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.upperActivationSpeedForwards_ms)
  return _internal_upperactivationspeedforwards_ms();
}
inline void configSteer_t::_internal_set_upperactivationspeedforwards_ms(float value) {
  _has_bits_[1] |= 0x00000010u;
  upperactivationspeedforwards_ms_ = value;
}
inline void configSteer_t::set_upperactivationspeedforwards_ms(float value) {
  _internal_set_upperactivationspeedforwards_ms(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.upperActivationSpeedForwards_ms)
}

// optional float lowerDeactivationSpeedForwards_ms = 885;
inline bool configSteer_t::_internal_has_lowerdeactivationspeedforwards_ms() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool configSteer_t::has_lowerdeactivationspeedforwards_ms() const {
  return _internal_has_lowerdeactivationspeedforwards_ms();
}
inline void configSteer_t::clear_lowerdeactivationspeedforwards_ms() {
  lowerdeactivationspeedforwards_ms_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float configSteer_t::_internal_lowerdeactivationspeedforwards_ms() const {
  return lowerdeactivationspeedforwards_ms_;
}
inline float configSteer_t::lowerdeactivationspeedforwards_ms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.lowerDeactivationSpeedForwards_ms)
  return _internal_lowerdeactivationspeedforwards_ms();
}
inline void configSteer_t::_internal_set_lowerdeactivationspeedforwards_ms(float value) {
  _has_bits_[0] |= 0x00001000u;
  lowerdeactivationspeedforwards_ms_ = value;
}
inline void configSteer_t::set_lowerdeactivationspeedforwards_ms(float value) {
  _internal_set_lowerdeactivationspeedforwards_ms(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.lowerDeactivationSpeedForwards_ms)
}

// optional float upperDeactivationSpeedForwards_ms = 1789;
inline bool configSteer_t::_internal_has_upperdeactivationspeedforwards_ms() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool configSteer_t::has_upperdeactivationspeedforwards_ms() const {
  return _internal_has_upperdeactivationspeedforwards_ms();
}
inline void configSteer_t::clear_upperdeactivationspeedforwards_ms() {
  upperdeactivationspeedforwards_ms_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline float configSteer_t::_internal_upperdeactivationspeedforwards_ms() const {
  return upperdeactivationspeedforwards_ms_;
}
inline float configSteer_t::upperdeactivationspeedforwards_ms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.upperDeactivationSpeedForwards_ms)
  return _internal_upperdeactivationspeedforwards_ms();
}
inline void configSteer_t::_internal_set_upperdeactivationspeedforwards_ms(float value) {
  _has_bits_[0] |= 0x00010000u;
  upperdeactivationspeedforwards_ms_ = value;
}
inline void configSteer_t::set_upperdeactivationspeedforwards_ms(float value) {
  _internal_set_upperdeactivationspeedforwards_ms(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.upperDeactivationSpeedForwards_ms)
}

// optional float lowerActivationSpeedBackwards_ms = 2600;
inline bool configSteer_t::_internal_has_loweractivationspeedbackwards_ms() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool configSteer_t::has_loweractivationspeedbackwards_ms() const {
  return _internal_has_loweractivationspeedbackwards_ms();
}
inline void configSteer_t::clear_loweractivationspeedbackwards_ms() {
  loweractivationspeedbackwards_ms_ = 0;
  _has_bits_[0] &= ~0x10000000u;
}
inline float configSteer_t::_internal_loweractivationspeedbackwards_ms() const {
  return loweractivationspeedbackwards_ms_;
}
inline float configSteer_t::loweractivationspeedbackwards_ms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.lowerActivationSpeedBackwards_ms)
  return _internal_loweractivationspeedbackwards_ms();
}
inline void configSteer_t::_internal_set_loweractivationspeedbackwards_ms(float value) {
  _has_bits_[0] |= 0x10000000u;
  loweractivationspeedbackwards_ms_ = value;
}
inline void configSteer_t::set_loweractivationspeedbackwards_ms(float value) {
  _internal_set_loweractivationspeedbackwards_ms(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.lowerActivationSpeedBackwards_ms)
}

// optional float upperActivationSpeedBackwards_ms = 2668;
inline bool configSteer_t::_internal_has_upperactivationspeedbackwards_ms() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool configSteer_t::has_upperactivationspeedbackwards_ms() const {
  return _internal_has_upperactivationspeedbackwards_ms();
}
inline void configSteer_t::clear_upperactivationspeedbackwards_ms() {
  upperactivationspeedbackwards_ms_ = 0;
  _has_bits_[0] &= ~0x20000000u;
}
inline float configSteer_t::_internal_upperactivationspeedbackwards_ms() const {
  return upperactivationspeedbackwards_ms_;
}
inline float configSteer_t::upperactivationspeedbackwards_ms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.upperActivationSpeedBackwards_ms)
  return _internal_upperactivationspeedbackwards_ms();
}
inline void configSteer_t::_internal_set_upperactivationspeedbackwards_ms(float value) {
  _has_bits_[0] |= 0x20000000u;
  upperactivationspeedbackwards_ms_ = value;
}
inline void configSteer_t::set_upperactivationspeedbackwards_ms(float value) {
  _internal_set_upperactivationspeedbackwards_ms(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.upperActivationSpeedBackwards_ms)
}

// optional float lowerDeactivationSpeedBackwards_ms = 827;
inline bool configSteer_t::_internal_has_lowerdeactivationspeedbackwards_ms() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool configSteer_t::has_lowerdeactivationspeedbackwards_ms() const {
  return _internal_has_lowerdeactivationspeedbackwards_ms();
}
inline void configSteer_t::clear_lowerdeactivationspeedbackwards_ms() {
  lowerdeactivationspeedbackwards_ms_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float configSteer_t::_internal_lowerdeactivationspeedbackwards_ms() const {
  return lowerdeactivationspeedbackwards_ms_;
}
inline float configSteer_t::lowerdeactivationspeedbackwards_ms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.lowerDeactivationSpeedBackwards_ms)
  return _internal_lowerdeactivationspeedbackwards_ms();
}
inline void configSteer_t::_internal_set_lowerdeactivationspeedbackwards_ms(float value) {
  _has_bits_[0] |= 0x00000800u;
  lowerdeactivationspeedbackwards_ms_ = value;
}
inline void configSteer_t::set_lowerdeactivationspeedbackwards_ms(float value) {
  _internal_set_lowerdeactivationspeedbackwards_ms(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.lowerDeactivationSpeedBackwards_ms)
}

// optional float upperDeactivationSpeedBackwards_ms = 227;
inline bool configSteer_t::_internal_has_upperdeactivationspeedbackwards_ms() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool configSteer_t::has_upperdeactivationspeedbackwards_ms() const {
  return _internal_has_upperdeactivationspeedbackwards_ms();
}
inline void configSteer_t::clear_upperdeactivationspeedbackwards_ms() {
  upperdeactivationspeedbackwards_ms_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float configSteer_t::_internal_upperdeactivationspeedbackwards_ms() const {
  return upperdeactivationspeedbackwards_ms_;
}
inline float configSteer_t::upperdeactivationspeedbackwards_ms() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.upperDeactivationSpeedBackwards_ms)
  return _internal_upperdeactivationspeedbackwards_ms();
}
inline void configSteer_t::_internal_set_upperdeactivationspeedbackwards_ms(float value) {
  _has_bits_[0] |= 0x00000040u;
  upperdeactivationspeedbackwards_ms_ = value;
}
inline void configSteer_t::set_upperdeactivationspeedbackwards_ms(float value) {
  _internal_set_upperdeactivationspeedbackwards_ms(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.upperDeactivationSpeedBackwards_ms)
}

// optional float rearSteerAngleRatio = 1939;
inline bool configSteer_t::_internal_has_rearsteerangleratio() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool configSteer_t::has_rearsteerangleratio() const {
  return _internal_has_rearsteerangleratio();
}
inline void configSteer_t::clear_rearsteerangleratio() {
  rearsteerangleratio_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline float configSteer_t::_internal_rearsteerangleratio() const {
  return rearsteerangleratio_;
}
inline float configSteer_t::rearsteerangleratio() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.rearSteerAngleRatio)
  return _internal_rearsteerangleratio();
}
inline void configSteer_t::_internal_set_rearsteerangleratio(float value) {
  _has_bits_[0] |= 0x00040000u;
  rearsteerangleratio_ = value;
}
inline void configSteer_t::set_rearsteerangleratio(float value) {
  _internal_set_rearsteerangleratio(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.rearSteerAngleRatio)
}

// optional uint32 minStaticObjectProbability_perc = 3245;
inline bool configSteer_t::_internal_has_minstaticobjectprobability_perc() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool configSteer_t::has_minstaticobjectprobability_perc() const {
  return _internal_has_minstaticobjectprobability_perc();
}
inline void configSteer_t::clear_minstaticobjectprobability_perc() {
  minstaticobjectprobability_perc_ = 0u;
  _has_bits_[1] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 configSteer_t::_internal_minstaticobjectprobability_perc() const {
  return minstaticobjectprobability_perc_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 configSteer_t::minstaticobjectprobability_perc() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.minStaticObjectProbability_perc)
  return _internal_minstaticobjectprobability_perc();
}
inline void configSteer_t::_internal_set_minstaticobjectprobability_perc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[1] |= 0x00000001u;
  minstaticobjectprobability_perc_ = value;
}
inline void configSteer_t::set_minstaticobjectprobability_perc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_minstaticobjectprobability_perc(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.minStaticObjectProbability_perc)
}

// optional uint32 minDynamicObjectProbability_perc = 2440;
inline bool configSteer_t::_internal_has_mindynamicobjectprobability_perc() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool configSteer_t::has_mindynamicobjectprobability_perc() const {
  return _internal_has_mindynamicobjectprobability_perc();
}
inline void configSteer_t::clear_mindynamicobjectprobability_perc() {
  mindynamicobjectprobability_perc_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 configSteer_t::_internal_mindynamicobjectprobability_perc() const {
  return mindynamicobjectprobability_perc_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 configSteer_t::mindynamicobjectprobability_perc() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.minDynamicObjectProbability_perc)
  return _internal_mindynamicobjectprobability_perc();
}
inline void configSteer_t::_internal_set_mindynamicobjectprobability_perc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00200000u;
  mindynamicobjectprobability_perc_ = value;
}
inline void configSteer_t::set_mindynamicobjectprobability_perc(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mindynamicobjectprobability_perc(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.minDynamicObjectProbability_perc)
}

// optional bool stopInterventionIfError_nu = 3855;
inline bool configSteer_t::_internal_has_stopinterventioniferror_nu() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool configSteer_t::has_stopinterventioniferror_nu() const {
  return _internal_has_stopinterventioniferror_nu();
}
inline void configSteer_t::clear_stopinterventioniferror_nu() {
  stopinterventioniferror_nu_ = false;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool configSteer_t::_internal_stopinterventioniferror_nu() const {
  return stopinterventioniferror_nu_;
}
inline bool configSteer_t::stopinterventioniferror_nu() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.stopInterventionIfError_nu)
  return _internal_stopinterventioniferror_nu();
}
inline void configSteer_t::_internal_set_stopinterventioniferror_nu(bool value) {
  _has_bits_[0] |= 0x01000000u;
  stopinterventioniferror_nu_ = value;
}
inline void configSteer_t::set_stopinterventioniferror_nu(bool value) {
  _internal_set_stopinterventioniferror_nu(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.stopInterventionIfError_nu)
}

// optional bool checkDoors_nu = 2707;
inline bool configSteer_t::_internal_has_checkdoors_nu() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool configSteer_t::has_checkdoors_nu() const {
  return _internal_has_checkdoors_nu();
}
inline void configSteer_t::clear_checkdoors_nu() {
  checkdoors_nu_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool configSteer_t::_internal_checkdoors_nu() const {
  return checkdoors_nu_;
}
inline bool configSteer_t::checkdoors_nu() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.checkDoors_nu)
  return _internal_checkdoors_nu();
}
inline void configSteer_t::_internal_set_checkdoors_nu(bool value) {
  _has_bits_[0] |= 0x02000000u;
  checkdoors_nu_ = value;
}
inline void configSteer_t::set_checkdoors_nu(bool value) {
  _internal_set_checkdoors_nu(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.checkDoors_nu)
}

// optional bool checkDriverSeatbelt_nu = 1677;
inline bool configSteer_t::_internal_has_checkdriverseatbelt_nu() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool configSteer_t::has_checkdriverseatbelt_nu() const {
  return _internal_has_checkdriverseatbelt_nu();
}
inline void configSteer_t::clear_checkdriverseatbelt_nu() {
  checkdriverseatbelt_nu_ = false;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool configSteer_t::_internal_checkdriverseatbelt_nu() const {
  return checkdriverseatbelt_nu_;
}
inline bool configSteer_t::checkdriverseatbelt_nu() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.checkDriverSeatbelt_nu)
  return _internal_checkdriverseatbelt_nu();
}
inline void configSteer_t::_internal_set_checkdriverseatbelt_nu(bool value) {
  _has_bits_[0] |= 0x04000000u;
  checkdriverseatbelt_nu_ = value;
}
inline void configSteer_t::set_checkdriverseatbelt_nu(bool value) {
  _internal_set_checkdriverseatbelt_nu(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.checkDriverSeatbelt_nu)
}

// optional bool checkTrunk_nu = 1989;
inline bool configSteer_t::_internal_has_checktrunk_nu() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool configSteer_t::has_checktrunk_nu() const {
  return _internal_has_checktrunk_nu();
}
inline void configSteer_t::clear_checktrunk_nu() {
  checktrunk_nu_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool configSteer_t::_internal_checktrunk_nu() const {
  return checktrunk_nu_;
}
inline bool configSteer_t::checktrunk_nu() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.checkTrunk_nu)
  return _internal_checktrunk_nu();
}
inline void configSteer_t::_internal_set_checktrunk_nu(bool value) {
  _has_bits_[0] |= 0x08000000u;
  checktrunk_nu_ = value;
}
inline void configSteer_t::set_checktrunk_nu(bool value) {
  _internal_set_checktrunk_nu(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.checkTrunk_nu)
}

// optional bool checkSeat_nu = 3889;
inline bool configSteer_t::_internal_has_checkseat_nu() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool configSteer_t::has_checkseat_nu() const {
  return _internal_has_checkseat_nu();
}
inline void configSteer_t::clear_checkseat_nu() {
  checkseat_nu_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool configSteer_t::_internal_checkseat_nu() const {
  return checkseat_nu_;
}
inline bool configSteer_t::checkseat_nu() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.checkSeat_nu)
  return _internal_checkseat_nu();
}
inline void configSteer_t::_internal_set_checkseat_nu(bool value) {
  _has_bits_[0] |= 0x00400000u;
  checkseat_nu_ = value;
}
inline void configSteer_t::set_checkseat_nu(bool value) {
  _internal_set_checkseat_nu(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.checkSeat_nu)
}

// optional bool torqueInterfaceActive_nu = 1116;
inline bool configSteer_t::_internal_has_torqueinterfaceactive_nu() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool configSteer_t::has_torqueinterfaceactive_nu() const {
  return _internal_has_torqueinterfaceactive_nu();
}
inline void configSteer_t::clear_torqueinterfaceactive_nu() {
  torqueinterfaceactive_nu_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool configSteer_t::_internal_torqueinterfaceactive_nu() const {
  return torqueinterfaceactive_nu_;
}
inline bool configSteer_t::torqueinterfaceactive_nu() const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t.torqueInterfaceActive_nu)
  return _internal_torqueinterfaceactive_nu();
}
inline void configSteer_t::_internal_set_torqueinterfaceactive_nu(bool value) {
  _has_bits_[0] |= 0x00800000u;
  torqueinterfaceactive_nu_ = value;
}
inline void configSteer_t::set_torqueinterfaceactive_nu(bool value) {
  _internal_set_torqueinterfaceactive_nu(value);
  // @@protoc_insertion_point(field_set:pb.mf_lsca.config_steer_t.configSteer_t.torqueInterfaceActive_nu)
}

// -------------------------------------------------------------------

// configSteer_t_array_port

// repeated .pb.mf_lsca.config_steer_t.configSteer_t data = 3770;
inline int configSteer_t_array_port::_internal_data_size() const {
  return data_.size();
}
inline int configSteer_t_array_port::data_size() const {
  return _internal_data_size();
}
inline void configSteer_t_array_port::clear_data() {
  data_.Clear();
}
inline ::pb::mf_lsca::config_steer_t::configSteer_t* configSteer_t_array_port::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:pb.mf_lsca.config_steer_t.configSteer_t_array_port.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::mf_lsca::config_steer_t::configSteer_t >*
configSteer_t_array_port::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:pb.mf_lsca.config_steer_t.configSteer_t_array_port.data)
  return &data_;
}
inline const ::pb::mf_lsca::config_steer_t::configSteer_t& configSteer_t_array_port::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::pb::mf_lsca::config_steer_t::configSteer_t& configSteer_t_array_port::data(int index) const {
  // @@protoc_insertion_point(field_get:pb.mf_lsca.config_steer_t.configSteer_t_array_port.data)
  return _internal_data(index);
}
inline ::pb::mf_lsca::config_steer_t::configSteer_t* configSteer_t_array_port::_internal_add_data() {
  return data_.Add();
}
inline ::pb::mf_lsca::config_steer_t::configSteer_t* configSteer_t_array_port::add_data() {
  // @@protoc_insertion_point(field_add:pb.mf_lsca.config_steer_t.configSteer_t_array_port.data)
  return _internal_add_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::mf_lsca::config_steer_t::configSteer_t >&
configSteer_t_array_port::data() const {
  // @@protoc_insertion_point(field_list:pb.mf_lsca.config_steer_t.configSteer_t_array_port.data)
  return data_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config_steer_t
}  // namespace mf_lsca
}  // namespace pb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mf_5flsca_2fconfig_5fsteer_5ft_2eproto
