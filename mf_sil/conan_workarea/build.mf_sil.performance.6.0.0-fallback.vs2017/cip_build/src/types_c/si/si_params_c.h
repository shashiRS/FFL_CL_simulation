//Attention, this file is generated by Cobolt from template: D:\.bbs_conan\c029a0\1\codegen\templates\types_c\struct.h.template!

#ifdef ECO_CPP_TYPES_USED
  #ifndef ECO_ALLOW_INTERFACE_MIXING
    #error eco C and C++ types mixed
  #endif
#endif
#ifdef ECO_CPP14_TYPES_USED
  #ifndef ECO_ALLOW_INTERFACE_MIXING
    #error eco C and C++14 types mixed
  #endif
#endif
#define ECO_C_TYPES_USED

#ifndef SI_SI_PARAMS_C_H_
#define SI_SI_PARAMS_C_H_

#include "eco/algo_interface_version_number_c.h"
#include "eco/signal_header_c.h"
#include "Platform_Types.h"
#include "eco/memset_c.h"

/// SI Parameters
typedef struct
{
    ECO_AlgoInterfaceVersionNumber uiVersionNumber;
    ECO_SignalHeader sSigHeader;
    ///If true the polygons read from the input are oriented counter-clockwise. If false they are clockwise
    boolean isStaticObjectInputCCWOriented;
    ///Additional overhang to compensate the fact that in the 2D plane a wheel stopper is partly covered by the wheels.
    float32 increaseOverhangLowObject_m;
    ///It controls the width of the ROI, that determines which objects taking into account of the covered interval calculation of the parking box.
    float32 coveredIntervalsRoiWidth_m;
    ///Base and performance only: if true reads lineMarkings from Input. Wheelstoppers in input will still be read regardless
    boolean useLineMarkings;
    ///If set to true, treat unknown curbside objects as body traversable objects.
    boolean treatUnknownCurbsideObjectsAsBodyTraversable;
    ///Enable/Disable the estimation of a parking maneuver based on the sampled trajectory
    boolean enableSlotIdentFromTrajectory;
    ///Threshold for the max. yaw deviation from the end position within the recorded trajectory for slot identification
    float32 slotIdentMaxYawDevParallel_rad;
    ///Threshold for max. deviation of a straight line within the recorded trajectory for slot identification
    float32 slotIdentMaxDevFromStraightLine_m;
    ///Enable parking scenarios where we only have the second delimiter and a curb object
    boolean enableSecondSideDelimiterOnlyScenario;
    ///Enable parking scenarios where we only have the first delimiter and a curb object
    boolean enableFirstSideDelimiterOnlyScenario;
    ///If true prefer second side OSD over first side OSD if both are possible
    boolean preferSecondSideOSD;
    ///Delta from vehicle front for OSD scan roi when moving forward (Otherwise use normal scanRoi)
    float32 osdSideRoiXFront_m;
    ///Delta from vehicle back for OSD scan roi when moving backward (Otherwise use normal scanRoi)
    float32 osdSideRoiXBack_m;
    ///If set to false, SI won"t require curb objects for one side delimiting (OSD) slots
    boolean requiredCurbObjectForOneSideDelimitingSlots;
    ///COMA shall not allow shrinking which results in total slot movement exceeding this value
    float32 horizontalMovementLimitOfASlotSlotCoords_m;
    ///Max. allowed distance the vehicle may overlap a low curb in a perpendicular slot.
    float32 maxAllowedVehCurbOverlapForPerp_m;
    ///the length of all low curb side objects combined must exceed this threshold in order to accept a one side delimiter parking slot
    float32 minCurbObjLengthForOneSideDel_m;
    ///SI won"t kill selected slot during park-in because of a missing delimiting object as long as the slot has at least one delimiting object.
    boolean allowNakedSlots;
    ///Set to false to allow naked slots without any delimiting object. Parameter used only when naked slots are enabled.
    boolean requireAtLeastOneDelimitingObjectForNakedSlot;
    ///(aligned) slot may be shifted towards road by that value (reaching out between delimiters). Side-effect: slotPenetrationDepth_m
    float32 maxRoadsideExtensionPerpendicular_m;
    ///(aligned) slot may be shifted towards road by that value (reaching out between delimiters. Side-effect: slotPenetrationDepth_m
    float32 maxRoadsideExtensionParallel_m;
    ///slot may be shifted towards road by that value (reaching out between delimiters. Side-effect: slotPenetrationDepth_m
    float32 maxRoadsideExtensionAngular_m;
    ///If applied, roadside extension shall not be smaller than this value
    float32 minAppliedRoadsideExtension_m;
    ///Minimum distance vehicle has to keep to objects
    float32 minDistanceToObject_m;
    ///Minimum distance vehicle has to keep to slot edges if no object on that side
    float32 minDistanceNoObject_m;
    ///Disable/Enable angular slot detection
    boolean enableAngularParking;
    ///Disable/Enable angular slot detection on the right with opening towards back of ego vehicle
    boolean enableAngularRightOpeningTowardsBack;
    ///Disable/Enable angular slot detection on the right with opening towards front of ego vehicle
    boolean enableAngularRightOpeningTowardsFront;
    ///Disable/Enable angular slot detection on the left with opening towards back of ego vehicle
    boolean enableAngularLeftOpeningTowardsBack;
    ///Disable/Enable angular slot detection on the left with opening towards front of ego vehicle
    boolean enableAngularLeftOpeningTowardsFront;
    ///if set to true, the detector will try different angles to detect angular slots if no line marking was detected.
    boolean enableAngularSlotBruteForceDetection;
    ///if set to true, the detector will calculate the virtual lines of side delimiting objects and use them to determine the slot orientation, if the VLs are long enough.
    boolean enableSlotPoseDetectionOnVirtualLines;
    ///Replacing parallel slots with squared distance equal or higher than this threshold regardless of their score to avoid having distant slots in the system only because they have a high score.
    float32 outlierDistSqrParallelSlot_m2;
    ///Replacing non parallel slots with squared distance equal or higher than this threshold regardless of their score to avoid having distant slots in the system only because they have a high score.
    float32 outlierDistSqrNonParallelSlot_m2;
    ///Do a replacement if new slot"s squared distance is smaller than the worst slot to replace by slotReplacementDeltaOutlierDistSqr_m2.
    float32 slotReplacementDeltaOutlierDistSqr_m2;
    ///absolute (not relative to ego vehicle) min width of the slot window for angular parking space detection
    float32 angularParkingDetectionWindowAbsMin_m;
    ///absolute (not relative to ego vehicle) max width of the slot window for angular parking space detection
    float32 angularParkingDetectionWindowAbsMax_m;
    ///TO BE TESTED: extension on the max depth of angular slots. So far an angular slot uses the same parameters as a
    ///perpendicular slot. However, if an angular slot is aligned on lines, the one closer to the road is picked for
    ///alignment and the slot is shifted a lot to the road. In this case it is too short if only the per max length is used.
    float32 angularSlotMaxDepthExtension_m;
    ///Disable/Enable parallel slot detection
    boolean enableParallelSlots;
    ///(aligned) Parallel slots must have opening greater or equal vehicle length + this margin
    float32 parallelSlotLengthDeltaMin_m;
    ///(NOT aligned) Parallel slots with unknown opening are modeled as vehicle length + this margin.Required for one-side delimiter parking
    float32 parallelSlotLengthDeltaModel_m;
    ///(aligned) Parallel slots must have opening lesser or equal vehicle length + this margin
    float32 parallelSlotLengthDeltaMax_m;
    ///(aligned) If there is no curbside object available, the slot depth is modeled as vehicle width + this margin
    float32 parallelSlotWidthDeltaModel_m;
    ///(aligned) Parallel slots must have a depth greater or equal vehicle width + this margin
    float32 parallelSlotWidthDeltaMin_m;
    ///(NOT aligned) Parallel slots must have depth lesser or equal vehicle width + this margin
    float32 parallelSlotWidthDeltaMax_m;
    ///max slot opening: offset to vehilce length during park in.
    float32 parallelSlotOpeningDeltaMaxPark_m;
    ///min slot opening: offset to vehilce length during park in.
    float32 parallelSlotOpeningDeltaMinPark_m;
    ///max slot depth: offset to vehilce width during park in.
    float32 parallelSlotDepthDeltaMaxPark_m;
    ///min slot depth: offset to vehilce width during park in.
    float32 parallelSlotDepthDeltaMinPark_m;
    ///Disable/Enable perpendicular slot detection
    boolean enablePerpendicularSlots;
    ///(aligned) Perpendicular slots must have opening greater or equal vehicle width + this margin
    float32 perpendicularSlotWidthDeltaMin_m;
    ///(NOT aligned) Perpendicular slots with unknown opening are modeled as vehicle width + this margin.
    float32 perpendicularSlotWidthDeltaModel_m;
    ///(aligned) Perpendicular slots must have opening lesser or equal vehicle width + this margin
    float32 perpendicularSlotWidthDeltaMax_m;
    ///(aligned) If there is no curbside object available, the slot depth is modeled as vehicle length + this margin
    float32 perpendicularSlotLengthDeltaModel_m;
    ///(aligned) Perpendicular slots must have a depth greater or equal vehicle length + this margin
    float32 perpendicularSlotLengthDeltaMin_m;
    ///(NOT aligned) Perpendicular slots must have a depth lesser or equal vehicle length + this margin
    float32 perpendicularSlotLengthDeltaMax_m;
    ///max slot opening: offset to vehilce width during park in.
    float32 perpendicularSlotOpeningDeltaMaxPark_m;
    ///min slot opening: offset to vehilce width during park in.
    float32 perpendicularSlotOpeningDeltaMinPark_m;
    ///max slot depth: offset to vehilce length during park in.
    float32 perpendicularSlotDepthDeltaMaxPark_m;
    ///min slot depth: offset to vehilce length during park in.
    float32 perpendicularSlotDepthDeltaMinPark_m;
    ///Disable/Enable garage slot detection
    boolean enableGarageParkingSlots;
    ///(NOT aligned) Garage slots must have opening greater or equal vehicle width + this margin
    float32 garageParkingSlotWidthDeltaMin_m;
    ///(NOT aligned) Garage slots must have opening lesser or equal vehicle width + this margin
    float32 garageParkingSlotWidthDeltaMax_m;
    ///(NOT aligned) Garage slots must have depth greater or equal vehicle width + this margin
    float32 garageParkingSlotLengthDeltaMin_m;
    ///(NOT aligned) If there is no curbside object detected, thes slot depth is modeled as vehicle length + this margin
    float32 garageParkingSlotLengthDeltaModel_m;
    ///(NOT aligned) Garage slots must have depth lesser or equal vehicle width + this margin
    float32 garageParkingSlotLengthDeltaMax_m;
    ///(NOT aligned) The entrange of a garage slot tha overlaps with the closing door is modeled by this value
    float32 garageParkingSlotDoorAreaLength_m;
    ///new detected slot are allowed to have a certain overlap due to corner cases
    float32 maxAllowedSlotOpeningOverlap_m;
    ///If true prefer shift to top if shifting means going below preferred width even if that means going below preferred depth
    boolean preferWideSlots;
    ///If set to true, SI will offer overlapping slots where applicable, Currently this works for OSD-perp and parallel
    boolean offerOverlappingSlots;
    ///Enable/Disable rotation optimization
    boolean performOptimization;
    ///0.0001F: distance to shrink the slot after adustment to objects and lines to account for numerical inaccuracy
    float32 shrinkSlotForNumericalInaccuracy_m;
    ///Slot opening positioning takes object parts this far to the left/right of the slot into account
    float32 slotPositioningRoiLeftRightDelta_m;
    ///Slot opening positioning takes object parts this for towards to the roadside of the slot into account
    float32 slotPositioningRoiRoadDelta_m;
    ///Objects within this radius are considered for the corner alignment part of the cost function
    float32 slotEdgePullSearchDistFront_m;
    ///max rotation of ego pose since slot detection before the parallel slot is invalidated
    float32 maxDrivenRotationParallel_rad;
    ///max rotation of ego pose since slot detection before the perpendicular slot is invalidated
    float32 maxDrivenRotationPerpendicular_rad;
    ///max rotation of ego pose since slot detection before the garage slot is invalidated
    float32 maxDrivenRotationGarage_rad;
    ///max rotation of ego pose since slot detection before the angled slot is invalidated
    float32 maxDrivenRotationAngled_rad;
    ///depth of ROI into the slot to align slots to horizontal lines
    float32 slotDepthHorizontalLineAlignment_m;
    ///if set to true, CollisionManager will maintain the selected slot during track even if its size falls below expected minimums
    boolean enableSlotShrinkingBelowUsualSizeDuringTrack;
    ///If two slots are fully established and overlap each other one of them should be invalidated
    boolean invalidateOverlappingEstablishedSlots;
    ///weight of curb orientation cost
    float32 weightCurbOrientation;
    ///TO BE TESTED: weight for orientation of the slot according to vertical lines
    float32 weightLineOrientation;
    ///if this much coverage is available per side, the slot is considered as sandwich slot and line orientation is not used in the cost function for non-parallel slots
    float32 minCoveragePerSideNonPar_m;
    ///Disable/Enable the slot orientation according to the virtual lines along the slot of side delimiting objects (i.e. the deviation to the virtual lines becomes a part of the optimization criterion)
    boolean enableSlotOrientationOnSideVLs;
    ///Disable/Enable the slot orientation according to the virtual lines along the street of side delimiting objects (i.e. the deviation to the virtual lines becomes a part of the optimization criterion)
    boolean enableSlotOrientationOnWingVLs;
    ///It controls the width of the ROI, that is used for the side alignment calculation in the cost function.
    float32 sideAlignmentROIWidth_m;
    ///Side alignment weight factor, that is used during the calculation of the performance score.
    float32 sideAlignmentWeight_mpr;
    ///Wing alignment weight factor, that is used during the calculation of the performance score.
    float32 wingAlignmentWeight_mpr;
    ///Length of the smallest acceptable "virtual line", fitted down an obstacle to determine slot orientation.
    float32 minimumObstacleFittedLineLength_m;
    ///roi for slot orientation according to adjacent lines
    float32 lineOrientationRoiDelta_m;
    ///if set to true, a slot that has only low side delimiting objects and no line markings is invalid.
    boolean highSideDelimiterRequired;
    ///depth delta for the roi of curb object evaluation. Object within this range below the slot are considered as curb objects.
    float32 curbObjectEvaluationRoiDepthDelta_m;
    ///-
    float32 parallelLineAllowedDeviation_rad;
    ///if set to true, dynamic objects are enlarged to compensate uncertainties.
    boolean enlargeDynObj;
    ///The higher the assumed max. object velocity, the larger the the dyn. object search ROI is set
    float32 dynObjMaxVel_mps;
    ///The longer the preview time, the larger the dyn. object search ROI is set
    float32 dynObjMaxPreviewTime_s;
    ///Objects with an existence probability below this threshold shall not be forwarded
    uint8 dynObjMinExistenceProb_perc;
    ///if set to true, the collision check between slot shifts and the ego vehicle takes into account the exact object position
    boolean doExactShiftVectorToEgoCollisionCheck;
    ///Minimum slot opening offset used to calculate the maximum side blow up.
    float32 minSlotOpeningOffsetSideBlowUp_m;
    ///Penalty parameter in case of one of the parking line which belongs to the parkingbox is long.
    float32 parallelSlotLineTooLongPenalty;
    ///if set to true, the slot length adaption to adjacent objects is enabled. The slot length will only be adjusted if no curb object or line is present.
    boolean enableSlotLengthAdaptionToAdjacentObjects;
    ///if set to true, the slot length adaption to adjacent lines is enabled. The slot length will only be adjusted if no curb object or line is present.
    boolean enableSlotLengthAdaptionToAdjacentLines;
    ///if set to true, the slot opening may be extended over lines to have minimum width
    boolean allowSlotExtensionOverLinesToMinOpening;
    ///The maximum length the slot may be extended over a line for each side.
    float32 maxAllowedSlotExtensionOverLinesToMinOpening_m;
    ///Allow the slot to be shrunk down to lines, even if there are objects available
    boolean allowShrinkOnLinesDespiteSideObjects;
    ///if set to true, shrinking to top on objects in curb area shall be preferred over shrinking to side
    boolean preferShiftToTopOnCurbObjects;
    ///penalty added to costs of unpreferred shrinks to side on objects in curb area
    float32 sideShiftPenaltyForCurbObjects;
    ///vertical offset to the default border of the curb area (positive value means closer to the slot opening)
    float32 preferShiftToTopRoiYBorderOffset_m;
    ///if set to true, an invalid slot will be kept alive for mTBD_numCyclesSlotFallback_nu SI cycles
    boolean enableSlotFallback;
    ///if set to true, a shift in unspecified direction (to a side and to top) is allowed for objects
    boolean enableUnspecifiedShift;
    ///Penalty for shrinking to minimum slot dimensions.
    float32 penaltyForShrinkToMinDim;
    ///Apply these penalty to zero-shifts which result from declaring static objects as dynamic.
    float32 shrinkPenaltyForClassifyingObjectAsDynamic;
    ///Apply this penalty to shifts beyond minimal values, highest penalty atm because trajpla no like small slots.
    float32 shrinkPenaltyForShiftBelowMin;
    ///Apply a penalty to shift beyond the given limitations.
    float32 shrinkPenaltyForExceedingGivenLimits;
    ///ROI extension parameter for side and curb delimiter calculation.
    float32 sideAndCurbDelimiterRoiExtension_m;
    ///It shift the bottom of the ROI for side and curb delimiter calculation.
    float32 sideAndCurbDelimiterRoiBottomShift_m;
    ///Likely deviation of an angled slot, from orthogonality. Note: required to be non-negative.
    float32 typicalOrientationOfAngledSlot_rad;
    ///If set to true SI will try to find parallel lines which match well together to delimit a parking box
    boolean doLineCategorization;
    ///Slot rotation penalty if a slot has an opening smaller than the minimum
    float32 smallSlotOpeningPenalty;
    ///LineCategorization Pair Match cost factor for angle diff
    float32 lcAngleCostFactor;
    ///LineCategorization Pair Match cost factor for line dist smaller than model line dist based on slot dimensions
    float32 lcLineDistCostFactor;
    ///LineCategorization Pair Match cost factor for common line length smaller than model length based on slot dimensions
    float32 lcLineLengthCostFactor;
    ///if left/right were found, but no road line is present try to categorize curb only
    boolean doCurbOnlyLineCategorization;
    ///Maximum difference of a potential curb line angle to left/right line (Optimum is HALF_PI) Not applicable for angular parking
    float32 lcCurbOnlyAngleDiff_rad;
    ///Maximum spatial difference between left/right curb endpoints and curb line
    float32 lcCurbOnlySpatialDiff_m;
    ///Disable/Enable whether line markings shall be ignored for sandwich slots
    boolean ignoreLinesForSandwichSlots;
    ///LineCategorization no curb line was found through line categorization then do not optimize on curb lines
    boolean lcNoCurbLineOptimizationIfNoCurbLc;
    ///Determines a Rectangular around the ego vehicle. Slots outside this window are not updated since we consider the data as unreliable
    float32 sensingRange_m;
    ///Detection zone is automatically adjusted so that it reaches this far into potential slots. MUST be below any minimum slot depth and should cover the relevant part of the entrance. Side-effect: Roadside Extension
    float32 slotPenetrationDepth_m;
    ///Disable/Enable left side slot scanning
    boolean enableLeftSideScanning;
    ///Disable/Enable right side slot scanning
    boolean enableRightSideScanning;
    ///Side detection zone starts this far away from the ego flank
    float32 sideRoiYStart_m;
    ///Side detection zone ends this far away from the ego flank
    float32 sideRoiYEnd_m;
    ///Side detection zone ends this far in front of the ego
    float32 sideRoiXFront_m;
    ///Side detection zone ends this far behind of the ego
    float32 sideRoiXBack_m;
    ///Disable/Enable front slot scanning
    boolean enableFrontScanning;
    ///Front detection zone goes this much to the left and right, seen from ego sides
    float32 frontRoiYSide_m;
    ///Front detection zone starts this far in front of the ego
    float32 frontRoiXStart_m;
    ///Front detection zone starts ends this far in front of the ego
    float32 frontRoiXEnd_m;
    ///Allow the detection of slots below min opening during scanning
    boolean allowNarrowSlotsScan;
    ///The maximum a line may protrude out of the scanRoi in a "Bad" direction (e.g. for right roi to the left)
    float32 lineOpeningDelimiterMaxRoadProtrusion_m;
    ///Project Line onto scanRoi axis (e.g. for right Roi {0.0, -1.0F}). Separate projection in good(curb) and bad(road) side (e.g. for right roi cutoff point is the top of the roi and good is away from the vehicle and bad is towards vehicle). The good projection has to be factor times larger than the bad projection to still be considered a lineOpeningDelimiter
    float32 lineOpeningDelimiterToCurbProjectionFactor;
    ///Disable/Enable CNN wheelstopper handling
    boolean enableCnnWheelStoppers;
    ///only effective if enableCnnWheelStoppers is set to true
    boolean enableCnnWheelStopperStatObjVerification;
    ///Wheelstopper belongs to a parking slot if it"s center is not outside the slot by this margin.
    float32 allowedWsPosOutsideSlot_m;
    ///if set to true, the result of the static object evaluation is ignored and any object within the respective ROI is considered to be a wheelstopper and replaced by the body traversable artificial object
    boolean wsStatObjIgnoreEvaluation;
    ///allowed distance between two CNN wheel stoppers for merging the wheel stoppers in case that wheel locker suppression is activated
    float32 allowedDistToExistingWsWithWlSuppression_m;
    ///allowed distance between two CNN wheel stoppers for merging the wheel stoppers in case that wheel locker suppression is deactivated
    float32 allowedDistToExistingWsWithoutWlSuppression_m;
    ///1. Level determines what kind of messages are outputted
    uint8 integrationMessagesLevel_nu;
    ///0. Determine for which internal component messages shall be provided. 0 means all
    uint8 integrationMessagesComponent_nu;
    ///Collision function roi is this far to the sides relative to ego
    float32 collFunctionRoiWidthDelta_m;
    ///Collision function roi is this far to the Front/back relative to ego
    float32 collFunctionRoiLengthDelta_m;
    ///Default delimiter object width
    float32 barrierDelimiterWidth_m;
    ///If the calculated barrier is below this value, it is considered as irrelevant and not provided in the output
    float32 minBarrierDelimiterLength_m;
    ///The next point of an object must be at least this far away to the side in slot coordinates to take the current point as outer base
    float32 minBarrierPointOverhang_m;
    ///Maximum Size of "Unspecified Zone" from "Center" towards Road for parallel Slots
    float32 delZoneRoadMaxRelToVehWidthPar_nu;
    ///Maximum Size of "Unspecified Zone" from "Center" towards Road for non-parallel Slots
    float32 delZoneRoadMaxRelToVehLengthNonPar_nu;
    ///Size of "Unspecified Zone" from "Center" towards Road for parallel Slots is (Depth * delZoneRoadFactorPar_nu_m) - delZoneRoadMinDistPar_m
    float32 delZoneRoadFactorPar_nu;
    ///Size of "Unspecified Zone" from "Center" towards Road for non-parallel Slots is (Depth * delZoneRoadFactorNonPar_nu) - delZoneRoadMinDistNonPar_m
    float32 delZoneRoadFactorNonPar_nu;
    ///Minimum distance the "Unspecified Zone" has to have from the road side edge for parallel slots
    float32 delZoneRoadMinDistNonPar_m;
    ///Minimum distance the "Unspecified Zone" has to have from the road side edge for non -parallel slots
    float32 delZoneRoadMinDistPar_m;
    ///Maximum Size of "Unspecified Zone" from "Center" towards Curb for parallel Slots
    float32 delZoneCurbMaxRelToVehWidthPar_nu;
    ///Maximum Size of "Unspecified Zone" from "Center" towards Curb for non-parallel Slots
    float32 delZoneCurbMaxRelToVehLengthNonPar_nu;
    ///Size of "Unspecified Zone" from "Center" towards curb for parallel Slots is (Depth * delZoneCurbFactorPar_nu)
    float32 delZoneCurbFactorPar_nu;
    ///Size of "Unspecified Zone" from "Center" towards curb for non-parallel Slots is (Depth * delZoneCurbFactorNonPar_nu)
    float32 delZoneCurbFactorNonPar_nu;
    ///Maximum Size of "Unspecified Zone" from "Center" towards left/right for parallel Slots
    float32 delZoneLeftRightMaxRelToVehLengthPar_nu;
    ///Size of "Unspecified Zone" from "Center" towards left Right for non-parallel slots is ((Opening of Left/Right) * delZoneLeftRightFactorNonPar_nu)
    float32 delZoneLeftRightFactorNonPar_nu;
    ///Maximum Size of "Unspecified Zone" from "Center" towards left/right for non-parallel Slots
    float32 delZoneLeftRightMaxRelToVehWidthNonPar_nu;
    ///Size of "Unspecified Zone" from "Center" towards left Right for parallel slots is ((Opening of Left/Right) * delZoneLeftRightFactorPar_nu)
    float32 delZoneLeftRightFactorPar_nu;
    ///All Delimiter zones are extended outwards (left and right) perpendicular to the slotby delimiterDist.
    float32 thDelimiterDist_m;
    ///(aligned) Dist between slot and inside zone
    float32 insideZoneDist_m;
    ///(aligned) the best projection must be at least as good as this factor compared to the second best for clear assignment to a zone
    float32 minRequiredDelimiterProjectionRatio_nu;
    ///Make objects inside delimiter even if they do not touch inside zone as long as they are not doo deep into the slot
    boolean enableInsideObjectPenetrationDepth;
    ///Determine how far an object may reach into the slot to still be considered as <inside> object
    float32 insideObjectMaxProjectionLength_m;
    ///If calculation of a VL fails for delimiters than provide a vl projected onto rect parking box instead if min length is met
    boolean vlProjectOntoBoxIfFailed;
    ///Maximum total angles between startingEdge and all vertices in one direction used for line fitting.
    float32 vlMaxTotalAngle_rad;
    ///Maximum angle between current edge and edge to next vertex possibly used for line fitting.
    float32 vlMaxNextEdgeAngle_rad;
    ///Minimum length of all relevant vertices projected onto the virtual line for a perpendicular left | right delimiter
    float32 vlMinVirtualLineLengthPerpSide_m;
    ///Minimum length of all relevant vertices projected onto the virtual line for a parallel left | right delimiter
    float32 vlMinVirtualLineLengthParSide_m;
    ///Minimum length of all relevant vertices projected onto the virtual line for a curb delimiter
    float32 vlMinVirtualLineLengthCurb_m;
    ///Minimum length of all relevant vertices projected onto the virtual line for a road delimiter
    float32 vlMinVirtualLineLengthRoad_m;
    ///If and only if set to true calculate inside VL and road-facing VL for side delimiters in NON-PaS scenarios and generate an optimized VL; Note: overrules vlUseRoadFacingForNonParallelSlots
    boolean vlDoRoadInsideOptimization;
    ///If set to true MEMM will create VL on road-facing side of an object for NON-PaS; Note: overruled by vlDoRoadInsideOptimization
    boolean vlUseRoadFacingForNonParallelSlots;
    ///When determining the vl algorithm"s start direction the direction most parallel to the related pBox edge is chosen. The first vertex in either direction with this value as a minimum distance is chosen to determine the parallelism.
    float32 vlMinLengthStartDirectionSq_m;
    ///if this * insideVlUsedForFitting > roadVlUsedForFitting then use inside Vl, otherwise road vl if vlDoRoadInsideOptimization is active
    float32 vlInsideLargerThanRoadFactor;
    ///Only allow a maximum angle of a virtual line to the parking box edge of the parking box rect
    boolean vlUseMaxAngleToParkingBoxEdge;
    ///The maximum angle a virtual line may have to the edge of the parking box rect if vlUseMaxAngleToParkingBoxEdge is set to true
    float32 vlMaxAngleToParkingBoxEdge_rad;
    ///Whether to do slotExpansion at all. This will enable expansion on staticObjects.
    boolean slotExpansion;
    ///If SlotExpansion is done, then whether to do it on lines as well
    boolean slotExpansionOnLines;
    ///Number of frames a calculated expansion has to be stable to actually take place
    uint8 slotExpFrameCounterStable_nu;
    ///Maximum difference of angles for a calculated expansion between frames to still be considered stable
    float32 slotExpMaxAngleDiff_rad;
    ///The maximum expansion for one triangle
    float32 slotExpMaxTriangleExpansion_m;
    ///The smallest necessary angle for an expansion to take place.
    float32 slotExpMinTriangleExpansion_rad;
    ///Width of the roi to check if the slot expansion should orientate itself on vertices in this roi
    float32 slotExpansionSideRoiWidth_m;
    ///Current immature definition: An object is considered as irrelevant if it fits in a square box with side = this value in ego coordinates
    float32 relevantObjectMinBoxSide_m;
    ///Enable/Disable object inflation
    boolean doObjectInflation;
    ///Enable/Disable usage of covariance matrix for object inflation
    boolean useCovMatrixInflation;
    ///(aligned?) default value to be used for object inflation
    float32 inflationSafetyDistanceDefault_m;
    ///(aligned?) specific value to be used for object inflation during park out
    float32 inflationSafetyDistanceParkOut_m;
    ///The maximum area that can be skipped per dent in the polygon
    float32 ncSplitMaxSkippableNCAreaPerStep_m2;
    ///Whether to use vertex with smallest X as start vertex or default method
    boolean ncSplitUseMostXStartIdx;
    ///Whether the non-convex split feature should be turned off or on
    boolean ncSplitOn;
    ///If and only if set to true SI will cluster objects in vicinity of parking slots.
    boolean doObjectClustering;
    ///Maximum distance of objects from the top down to still be clustered for side zones
    float32 ocPerpMaxDistanceSide_m;
    ///Maximum distance of objects from the top down to still be clustered for curb zones
    float32 ocPerpMaxDistanceCurb_m;
    ///The maximum distance objects may have (ordered by x direction) to still be clustered for perpendicular slots
    float32 ocPerpendicularMaxDistanceXForCurbSideClustering_m;
    ///The maximum distance objects may have (ordered by x direction) to still be clustered for parallel slots
    float32 ocParallelMaxDistanceXForCurbSideClustering_m;
    ///Maximum distance of objects from the top down to still be clustered for curb zones
    float32 ocAngMaxDistanceCurb_m;
    ///The Opening(Width) of a Primary Side(Left/Right) Zone for a Perpendicular slot
    float32 ocPrimZonePerpSideOpening_m;
    ///The Opening(Width) of a Primary Side(Left/Right) Zone for an Angular slot
    float32 ocPrimZoneAngSideOpening_m;
    ///The Opening(Width) of a Primary Side(Left/Right) Zone for a Parallel slot
    float32 ocPrimZoneParSideOpening_m;
    ///How far the Curb primary zone gets extended in Curb direction starting from slot curb edge
    float32 ocPrimZoneCurbBelowSlot_m;
    ///How far the Curb primary zone gets extended in road direction starting from slot curb edge for perpendicular slots
    float32 ocPrimZonePerpCurbIntoSlot_m;
    ///How far the Curb primary zone gets extended in road direction starting from slot curb edge for angular slots
    float32 ocPrimZoneAngCurbIntoSlot_m;
    ///How far the Curb primary zone gets extended in road direction starting from slot curb edge for parallel slots
    float32 ocPrimZoneParCurbIntoSlot_m;
    ///How far the side primary zone gets extended in road direction starting from slot road edge for perpendicular slots
    float32 ocPrimZonePerpSideToRoad_m;
    ///How far the side primary zone gets extended in road direction starting from slot road edge for parallel slots
    float32 ocPrimZoneParSideToRoad_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Side Zone further away from the slot
    float32 ocSecZonePerpSideToSide_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Side Zone into the slot
    float32 ocSecZonePerpSideToSlot_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Side Zone towards the road
    float32 ocSecZonePerpSideToRoad_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Side Zone towards the curb
    float32 ocSecZonePerpSideToCurb_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Curb Zone towards the Side(Left/Right)
    float32 ocSecZonePerpCurbToSide_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Curb Zone towards the Road
    float32 ocSecZonePerpCurbToRoad_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Curb Zone towards the curb
    float32 ocSecZonePerpCurbToCurb_m;
    ///The offset of a Secondary Zone to an Angular Slot Primary Side Zone further away from the slot
    float32 ocSecZoneAngSideToSide_m;
    ///The offset of a Secondary Zone to an Angular Slot Primary Side Zone into the slot
    float32 ocSecZoneAngSideToSlot_m;
    ///The offset of a Secondary Zone to an Angular Slot Primary Side Zone towards the road
    float32 ocSecZoneAngSideToRoad_m;
    ///The offset of a Secondary Zone to an Angular Slot Primary Side Zone towards the curb
    float32 ocSecZoneAngSideToCurb_m;
    ///The offset of a Secondary Zone to an Angular Slot Primary Curb Zone towards the Side(Left/Right)
    float32 ocSecZoneAngCurbToSide_m;
    ///The offset of a Secondary Zone to an Angular Slot Primary Curb Zone towards the Road
    float32 ocSecZoneAngCurbToRoad_m;
    ///The offset of a Secondary Zone to an Angular Slot Primary Curb Zone towards the curb
    float32 ocSecZoneAngCurbToCurb_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Side Zone further away from the slot
    float32 ocSecZoneParSideToSide_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Side Zone into the slot
    float32 ocSecZoneParSideToSlot_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Side Zone towards the road
    float32 ocSecZoneParSideToRoad_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Side Zone towards the curb
    float32 ocSecZoneParSideToCurb_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Curb Zone towards the Side(Left/Right)
    float32 ocSecZoneParCurbToSide_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Curb Zone towards the Road
    float32 ocSecZoneParCurbToRoad_m;
    ///The offset of a Secondary Zone to a Perpendicular Slot Primary Curb Zone towards the curb
    float32 ocSecZoneParCurbToCurb_m;
    ///Maximum allowed overlap of triangle expansion over objects, perpendicularly from the resulting triangular expansion edge towards most critical vertex of objects
    float32 outsideInAllowedOverlap_m;
    ///Allowed overlap of side ROI over main ROI for Triangle expansion
    float32 sideAllowedOverlap_m;
    ///Whether to use area criteria to determine which side to expand, or angle criteria
    boolean useAreaCriteria;
    ///Factor by which to prefer Road/Curb expansion over Left/Right
    float32 angularCurbRoadAreaFactor;
    ///Relative length of a single prohibition zone to the edge of a slot for triangle expansion
    float32 prohibitionZoneRelativeLength;
    ///Whether to use the linear overlap drop off for triangle expansion
    boolean useLinearOverlapDropOff;
    ///If inside.Fitting_length > this value then consider Inside Vl even if inside.Fitting_length < Factor * roadside.Fitting_length
    float32 vlInsideLargeEnough_m;
    ///if angle between roadSideVl and insideVl is larger than this value (Assuming they should be parallel) then use the roadSideVl
    float32 vlMaxAllowedRoadInsideAngleDiff_rad;
    ///Whether to do triangular expansion for the road side or not
    boolean teCalculateRoadSideExpansion;
    ///If and only if set to true MEMM will utilize getScoreHighComplexity() else getScoreLowComplexity()
    boolean delZonesUseHighComplexityGetScore;
    ///enables the verification of slot prototypes with CNN based slots
    boolean cnnSlotsEnableSiSlotDetectionVerification;
    ///If true compare slot types of cnn slots to si detected slots
    boolean cnnCompareSlotTypeFPSuppression;
    ///the cnn slot type confidence of one scenario has to be this value larger than others to be a distinct Scenario (perp, par, ang)
    uint8 cnnSlotsMinScenarioConfidenceTheshold;
    ///If true and enableSlotDetectionVerificationByCnnBasedSlot and cnnCompareSlotTypeFPSuppression are true as well then perpendicular cnn slots validate angular SI slots
    boolean cnnSlotsPerpendicularValidatesAngular;
    ///Maximum angle difference that the cnn and SI slot may have for the SI slot to be validated
    float32 cnnSlotsValidationMaxOpeningAngleDiff_rad;
    ///enables CNN based slot prototypes. These prototypes will be added to the internal parking space list.
    boolean cnnSlotsEnableCnnSlotPrototypes;
    ///Slots linked to a cnn slot may be naked slots.
    boolean allowNakedCnnSlots;
    ///Maximum distance an object may have to a parallel slot on side to be considered for slot blow up
    float32 cnnSlotBlowUpLimitParSide_m;
    ///Maximum distance an object may have to a parallel slot on the curb side to be considered for slot blow up
    float32 cnnSlotBlowUpLimitParCurb_m;
    ///Maximum distance an object may have to a parallel slot towards the road side to be considered for road edge alignment
    float32 cnnSlotRoadAlignmentLimitPar_m;
    ///Maximum distance an object may have to a non-parallel slot on the side to be considered for slot blow up
    float32 cnnSlotBlowUpLimitNonParSide_m;
    ///Maximum distance an object may have to a non-parallel slot on the curb side to be considered for slot blow up
    float32 cnnSlotBlowUpLimitNonParCurb_m;
    ///Maximum distance an object may have to a non-parallel slot towards the road side to be considered for road edge alignment
    float32 cnnSlotRoadAlignmentLimitNonPar_m;
    ///cnnOrientationError = -(this * angleDiff_rad)^2
    float32 cnnOrientationErrorCostFunctionFactor;
    ///If an SI Slot was not validated by a CNN Slot still allow the slot if it matches certain criteria
    boolean cnnSlotsAllowSiSlotOverride;
    ///SI High If an SI parallel slot was detected on lines, only increase the score if the lines are below max length
    float32 slotScoringMaxParLineLength_m;
    ///SI High If an SI parallel slot was detected on objects, only increase the score if the object has a WingVlLength of this param or higher
    float32 slotScoringMinParWingLength_m;
    ///SI High If an SI non parallel slot was detected on objects, only increase the score if the object has a SideVlLength of this param or higher
    float32 slotScoringMinNonParSideLength_m;
    ///SI High If an SI non parallel slot was detected on objects or lines, only increase the score if the respective vl or surrounding lines are at most this angle towards the slot
    float32 slotScoringMaxVlOrLineAngleDiff_rad;
    ///How much a cnn slot and a SI Slot have to overlap for the cnn slot to be able to validate the SI Slot
    float32 cnnSlotsMinValidationOverlap_m;
    ///how much a cnn slot and a SI Slot have to overlap for the cnn slot to be able to invalidate the SI Slot
    float32 cnnSlotsMinInvalidationOverlap_m;
    ///Distance threshold to calculate if the cnn slot is closer than any slot currently in parkingSpaceList if it is full. Goal is to avoid toggling between to CNN Slot Based slots.
    float32 minDistGapCnnSlotVsTrackedSlot_m;
    ///Enlarging the opening of od only slots to make sure tapos fits.
    float32 cnnSlotOdSlotEnlargement_m;
    ///Extension of slot compared to vehicle"s bounding box in all directions
    float32 memParkExtendSlot_m;
    ///Initial slot position is centered in x-direction at ego vehicle"s center. This value will adjust the x-position relatively (ego vehicle coordinate system).
    float32 leftRightMemParkOffsetX_m;
    ///Gap between ego vehicle and slot at right or left side of the ego vehicle
    float32 leftRightMemParkGapY_m;
    ///Gap between ego vehicle and slot in front of the ego vehicle
    float32 frontMemParkGap_m;
    ///Gap between ego vehicle and slot rear to the ego vehicle
    float32 rearMemParkGap_m;
    ///In user-defined slots, the maximum allowed abs rotation of the user adjustment.
    float32 maxMemParkRotAdj_rad;
    ///In user-defined slots, the maximum allowed linear translation of the user adjustment.
    float32 maxMemParkLinearAdj_m;
    ///If set to true, the maximum allowed road side extension shall be applied to parking spaces, if possible.
    boolean preapplyRoadsideExtension;
    ///Safety margin of dynamic object enlarging for pedestrians
    float32 safetyMarginDynObjEnlargingPed_m;
    ///Safety margin of dynamic object enlarging for cars
    float32 safetyMarginDynObjEnlargingCar_m;
    ///HIGH ONLY | Minimum height confidence delta threshold of static ojbects, which used to decide that the object is body traversable or high.
    uint8 minHeightConfDeltaStaticObj;
    ///Dummy floats for "experimental" features
    float32 developerGenericFloat0;
    ///Dummy floats for "experimental" features
    float32 developerGenericFloat1;
    ///Dummy floats for "experimental" features
    float32 developerGenericFloat2;
    ///Dummy floats for "experimental" features
    float32 developerGenericFloat3;
    ///Dummy floats for "experimental" features
    float32 developerGenericFloat4;
    ///Dummy floats for "experimental" features
    float32 developerGenericFloat5;
} SI_SiParams;

inline SI_SiParams create_SI_SiParams(void)
{
  SI_SiParams m;
  (void) ECO_memset (&m, 0, sizeof(m));
  m.sSigHeader = create_ECO_SignalHeader();
  return m;
}

#endif // SI_SI_PARAMS_C_H_
