// Attention, this file is generated by Cobolt from template: D:\.bbs_conan\c029a0\1\codegen\templates\types\struct.h.template!

#ifdef ECO_C_TYPES_USED
  #ifndef ECO_ALLOW_INTERFACE_MIXING
    #error eco C and C++ types mixed
  #endif
#endif
#ifdef ECO_CPP14_TYPES_USED
  #ifndef ECO_ALLOW_INTERFACE_MIXING
    #error eco C++ and C++14 types mixed
  #endif
#endif
#define ECO_CPP_TYPES_USED

#ifndef AP_TRJCTL_TRAJ_CTRL_DEBUG_PORT_H_
#define AP_TRJCTL_TRAJ_CTRL_DEBUG_PORT_H_

#include "eco/algo_interface_version_number.h"
#include "eco/signal_header.h"
#include "Platform_Types.h"
#include "eco/memset.h"


namespace ap_trjctl
{

  /// Debug port of component
  struct TrajCtrlDebugPort
  {
    ::eco::AlgoInterfaceVersionNumber uiVersionNumber;
    ::eco::SignalHeader sSigHeader;
    ///@unit{nu}
    ///Freespace for MTS debug values
    sint32 debugInt[10];
    ///@unit{nu}
    ///Freespace for MTS debug values
    float32 debugFloat[10];
    ///@unit{m}
    ///@range{-2,2}
    ///Current lateral deviation of vehicle from interpolated trajectory at rear axle. (based on orthogonal projection)
    float32 currentDeviation_m;
    ///@unit{rad}
    ///@range{-3142,3142}
    ///Current orientation error of vehicle from interpolated trajectory at rear axle. (based on orthogonal projection)
    float32 orientationError_rad;
    ///@unit{mps}
    ///@range{0,5}
    ///Interpolated velocity limit of trajectory.
    float32 velocityLimitReqInterpolTraj_mps;
    ///@unit{m}
    ///@range{-2,30}
    ///Interpolated/Extrapolated distance to stop of trajectory.
    float32 distanceToStopReqInterExtrapolTraj_m;
    ///@unit{m}
    ///Interpolated x value of trajectory.
    float32 xInterpolTraj_m;
    ///@unit{m}
    ///Interpolated y value of trajectory.
    float32 yInterpolTraj_m;
    ///@unit{1/m}
    ///@range{-0.3,0.3}
    ///Interpolated curvature value of trajectory.
    float32 curvatureInterpolTraj_1pm;
    ///@unit{1/m}
    ///Previewed curvature of the trajectory
    float32 curvaturePreviewed_1pm;
    ///@range{0,1}
    ///Filtered value of steer intervention flag.
    float32 filteredSteerIntervention_nu;
    ///Intermediate value on trajectory.
    float32 trajIntermediateValueRaw_perc;
    ///@unit{rad}
    ///Steer angle raw value.
    float32 steerAngReqRaw_rad;
    ///@unit{rad}
    ///Steer angle request based on yaw deviation.
    float32 steerAngReqYawDeviation_rad;
    ///@unit{rad}
    ///Steer angle request based on lateral deviation.
    float32 steerAngReqLateralDeviation_rad;
    ///@unit{rad}
    ///Steer angle request based on curvature.
    float32 steerAngReqCurvature_rad;
    ///@range{0,128}
    ///Current index on trajectory.
    uint8 currentTrajectoryIndex_nu;
    ///@range{0,128}
    ///Path control request mode.
    uint8 pathControlRequestMode_nu;
    ///@range{0,128}
    ///Raw steer angle request mode
    uint8 rawSteerAngleRequestMode_nu;
    ///@range{0,128}
    ///Rate and Acceleration limitation mode.
    uint8 rateAndAccelerationLimitatMode;
    ///@range{0,128}
    ///Comfortable standstill steering mode. (comfortable steering)
    uint8 comfStandStillSteeringMode_nu;
    ///@range{0,128}
    ///Comfortable standstill steering extrapolation mode at end of standstill steering
    uint8 comfStandstillSteeringExtrapolationMode_nu;
    ///Processed information that driver intervention was detected. (Schmitt-Trigger based evaluation output)
    boolean driverInterventionProcessed_nu;
    ///Information that driver intervention was detected.
    boolean driverInterventionDetected_nu;
    ///@unit{Boolean}
    ///free
    boolean free1;
    ///@unit{Boolean}
    ///free
    boolean free2;
    ///Information whether current gear compared to target gear is correct.
    boolean gearCorrect_nu;
    ///Information whether standstill steering is desired.
    boolean standstillSteeringDesired_nu;
    ///Information whether distance control is finished.
    boolean distanceControlFinished_nu;
    ///Information whether standstillHoldCur is reached.
    boolean standstillHoldCur_nu;
    ///Information whether finalVehicleStateReached is reached.
    boolean finalVehicleStateReached_nu;
    ///Flag for outside trajectory (start).
    boolean outsideTrajectoryStart_nu;
    ///Flag for outside trajectory (end).
    boolean outsideTrajectoryEnd_nu;
  };

  inline ::ap_trjctl::TrajCtrlDebugPort createTrajCtrlDebugPort()
  {
    TrajCtrlDebugPort m;
    (void)::eco::memset(&m, 0U, sizeof(TrajCtrlDebugPort));
    m.sSigHeader = ::eco::createSignalHeader();
    return m;
  }

} // namespace ap_trjctl

namespace eco
{
  template<class T>
  inline T create_default();

  template<>
  inline ::ap_trjctl::TrajCtrlDebugPort create_default()
  {
      return ::ap_trjctl::createTrajCtrlDebugPort();
  }
}


#endif // AP_TRJCTL_TRAJ_CTRL_DEBUG_PORT_H_
