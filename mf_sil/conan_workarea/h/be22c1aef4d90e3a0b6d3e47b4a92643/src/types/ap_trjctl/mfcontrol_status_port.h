// Attention, this file is generated by Cobolt from template: D:\.bbs_conan\c029a0\1\codegen\templates\types\struct.h.template!

#ifdef ECO_C_TYPES_USED
  #ifndef ECO_ALLOW_INTERFACE_MIXING
    #error eco C and C++ types mixed
  #endif
#endif
#ifdef ECO_CPP14_TYPES_USED
  #ifndef ECO_ALLOW_INTERFACE_MIXING
    #error eco C++ and C++14 types mixed
  #endif
#endif
#define ECO_CPP_TYPES_USED

#ifndef AP_TRJCTL_MFCONTROL_STATUS_PORT_H_
#define AP_TRJCTL_MFCONTROL_STATUS_PORT_H_

#include "eco/algo_interface_version_number.h"
#include "eco/signal_header.h"
#include "Platform_Types.h"
#include "ap_trjctl/lodmc_handshake_failed_status.h"
#include "ap_trjctl/ladmc_handshake_failed_status.h"
#include "ap_trjctl/lateral_control_saturation_status.h"
#include "eco/memset.h"


namespace ap_trjctl
{

  /// Status signals for handshake / communication with extern /overlaid function components. (e.g. Parking State Machine and Trajectory Planning)
  struct MFControlStatusPort
  {
    ::eco::AlgoInterfaceVersionNumber uiVersionNumber;
    ::eco::SignalHeader sSigHeader;
    ///@range{0,255}
    ///Number of used trajectory points in planned trajectory input for trajectory control. (e.g. if value is 5 the trajectory points with index 0,1,2,3,4 are used) (Changing trajectory points (e.g. dynamic replanning) with an index below might cause issues in the control loop e.g. jerks in steering wheel)
    uint8 numUsedCtrlPoints_nu;
    ///@range{0,4}
    ///Information that handshake with LODMC could not be established, specifies which type of function request failed handshake with LODMC.
    LodmcHandshakeFailedStatus lodmcHandshakeFailedStatus_nu;
    ///@range{0,3}
    ///Information that handshake with LADMC could not be established, specifies which type of function request failed handshake with LADMC.
    LadmcHandshakeFailedStatus ladmcHandshakeFailedStatus_nu;
    ///Information that the engaged gear is correct regarding the requested driving direction.
    boolean correctGearEngaged_nu;
    ///Information that longitudinal control request was finished. (e.g. requested stop point reached in case of distance control)
    boolean longitudinalControlFinished_nu;
    ///Information that lateral control request was finished. (e.g. requested steer angle reached in case of steer angle request)
    boolean lateralControlFinished_nu;
    ///Information that longitudinal control failed. (e.g. overshoot of requested stop point in case of distance control)
    boolean longitudinalControlFailed_nu;
    ///Information that lateral path control failed. (e.g. too high deviation from trajectory)
    boolean lateralPathControlFailed_nu;
    ///Information that longitudinal path control failed. (e.g. longitudinal outside trajectory in critical distance)
    boolean longitudinalPathControlFailed_nu;
    ///Information that lateral control failed. (e.g. a requested steer angle can"t be reached because of blockage of wheels)
    boolean lateralControlFailed_nu;
    ///Information that longitudinal control is saturated. (e.g. a requested control request can"t be performed in the requested driving direction because of driving resistance blocking the driving path)
    boolean longitudinalControlSaturated_nu;
    ///@range{0,3}
    ///Information about lateral control saturation status: is not in saturation or in saturation to the left or to the right or unknown direction. (e.g. a requested steer angle can"t be reached because of blockage of wheels)
    LateralControlSaturationStatus lateralControlSaturationStatus_nu;
    ///Information that vehicle standstill is hold by brake system.
    boolean vehStandstillHold_nu;
    ///Information that the vehicle is secured. (e.g. via electric parking brake)
    boolean vehStandstillSecured_nu;
    ///Information that a driver steer intervention was detected.
    boolean driverSteerIntervDetected_nu;
  };

  inline ::ap_trjctl::MFControlStatusPort createMFControlStatusPort()
  {
    MFControlStatusPort m;
    (void)::eco::memset(&m, 0U, sizeof(MFControlStatusPort));
    m.sSigHeader = ::eco::createSignalHeader();
    m.numUsedCtrlPoints_nu = 255U;
    return m;
  }

} // namespace ap_trjctl

namespace eco
{
  template<class T>
  inline T create_default();

  template<>
  inline ::ap_trjctl::MFControlStatusPort create_default()
  {
      return ::ap_trjctl::createMFControlStatusPort();
  }
}


#endif // AP_TRJCTL_MFCONTROL_STATUS_PORT_H_
