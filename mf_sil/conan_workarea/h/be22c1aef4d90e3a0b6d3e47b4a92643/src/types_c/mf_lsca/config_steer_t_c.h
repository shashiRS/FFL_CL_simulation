//Attention, this file is generated by Cobolt from template: D:\.bbs_conan\c029a0\1\codegen\templates\types_c\struct.h.template!

#ifdef ECO_CPP_TYPES_USED
  #ifndef ECO_ALLOW_INTERFACE_MIXING
    #error eco C and C++ types mixed
  #endif
#endif
#ifdef ECO_CPP14_TYPES_USED
  #ifndef ECO_ALLOW_INTERFACE_MIXING
    #error eco C and C++14 types mixed
  #endif
#endif
#define ECO_C_TYPES_USED

#ifndef MF_LSCA_CONFIG_STEER_T_C_H_
#define MF_LSCA_CONFIG_STEER_T_C_H_

#include "mf_lsca/config_steer_propose_t_c.h"
#include "cml/vec2_df_pod_c.h"
#include "mf_lsca/config_steer_resist_t_c.h"
#include "Platform_Types.h"
#include "eco/memset_c.h"

/// Struct that contains all relevant general parameter data for the steering functions
typedef struct
{
    ///Steering Proposal specific data
    MF_LSCA_configSteerPropose_t proposalData;
    ///Maximum allowed steering angles in degree
    CML_Vec2Df_POD maxSteeringAngleLimits_deg;
    ///Maximum allowed steering angle rate in degree per second
    CML_Vec2Df_POD maxSteeringAngleDelta_deg;
    ///Maximum allowed steering torques in NM
    CML_Vec2Df_POD maxSteeringTorqueLimits_Nm;
    ///Maximum allowed steering torque rate in Nm per second
    CML_Vec2Df_POD maxSteeringTorqueDelta_Nms;
    ///Steering resistance specific data
    MF_LSCA_configSteerResist_t resistanceData;
    ///Minimum length of the ROI
    float32 roiLengthOffset_m;
    ///Multiplier for velicity dependent ROI length
    float32 roiLength_s;
    ///Minimum width of the ROI
    float32 roiWidthOffset_m;
    ///Multiplier for velicity dependent ROI length
    float32 roiWidth_s;
    ///Minimum travelled distance within the ROI for steering proposal
    float32 roiTravelledDistOffsetProp_m;
    ///Minimum travelled distance within the ROI for steering resistance
    float32 roiTravelledDistOffsetResist_m;
    ///Multiplier for travelled distance within the ROI for steering proposal
    float32 roiTravelledDistProp_s;
    ///Multiplier for travelled distance within the ROI for steering resistance
    float32 roiTravelledDistResist_s;
    ///Enlargement of ego shape to the front
    float32 enlargementFront_m;
    ///Enlargement of ego shape to the rear
    float32 enlargementRear_m;
    ///Enlargement of ego shape to the side
    float32 enlargementSide_m;
    ///Driver hand torque which when exceeded immediatly disables steering functionalities
    float32 immediateOverrideTorque_Nm;
    ///Driver hand torque which when exceeded for more than overrideTime_s seconds disables steering functionalities
    float32 timeBasedOverrideTorque_Nm;
    ///Time during which the driver hand torque needs to exceed timeBasedOverrideTorque_Nm before disabling steering functionalities
    float32 overrideTime_s;
    ///Distance to drive before steering is re-enabled after override by driver hand torque
    float32 overrideDistance_m;
    ///Minimum speed that needs to be exceeded for function activation - forwards
    float32 lowerActivationSpeedForwards_ms;
    ///Maximum speed that must not be exceeded for function activation - forwards
    float32 upperActivationSpeedForwards_ms;
    ///Minimum speed that needs to be exceeded for function to become deactivated - forwards
    float32 lowerDeactivationSpeedForwards_ms;
    ///Maximum speed that must not be exceeded for function to become deactivated - forwards
    float32 upperDeactivationSpeedForwards_ms;
    ///Minimum (unsigned consideration) speed that needs to be exceeded for function activation - backwards
    float32 lowerActivationSpeedBackwards_ms;
    ///Maximum (unsigned consideration) speed that must not be exceeded for function activation - backwards
    float32 upperActivationSpeedBackwards_ms;
    ///Minimum (unsigned consideration) speed that needs to be exceeded for function to become deactivated - backwards
    float32 lowerDeactivationSpeedBackwards_ms;
    ///Maximum (unsigned consideration) speed that must not be exceeded for function to become deactivated - backwards
    float32 upperDeactivationSpeedBackwards_ms;
    ///Ratio between rear and front steering angle
    float32 rearSteerAngleRatio;
    ///Minimum required static detection probability for the function to react on an object
    uint8 minStaticObjectProbability_perc;
    ///Minimum required dynamic detection probability for the function to switch off if a dynamic onject is within the ROI
    uint8 minDynamicObjectProbability_perc;
    ///Stop the steering intervention if a sensor error is detected
    boolean stopInterventionIfError_nu;
    ///Disable steering function if a door is opened
    boolean checkDoors_nu;
    ///Disable steering function if the driver"s seatbelt is not fastened
    boolean checkDriverSeatbelt_nu;
    ///Disable steering function if the trunk is opened
    boolean checkTrunk_nu;
    ///Disable steering function if the driver"s seat is not occupied
    boolean checkSeat_nu;
    ///Indicates true if steering by torque is active, otherwise steering by angle is active
    boolean torqueInterfaceActive_nu;
} MF_LSCA_configSteer_t;

inline MF_LSCA_configSteer_t create_MF_LSCA_configSteer_t(void)
{
  MF_LSCA_configSteer_t m;
  (void) ECO_memset (&m, 0, sizeof(m));
  m.proposalData = create_MF_LSCA_configSteerPropose_t();
  m.maxSteeringAngleLimits_deg = create_CML_Vec2Df_POD();
  m.maxSteeringAngleDelta_deg = create_CML_Vec2Df_POD();
  m.maxSteeringTorqueLimits_Nm = create_CML_Vec2Df_POD();
  m.maxSteeringTorqueDelta_Nms = create_CML_Vec2Df_POD();
  m.resistanceData = create_MF_LSCA_configSteerResist_t();
  return m;
}

#endif // MF_LSCA_CONFIG_STEER_T_C_H_
