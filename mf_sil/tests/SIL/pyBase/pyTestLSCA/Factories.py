#********************************************************************# System Imports#********************************************************************import sysimport impimp.reload(sys)# sys.setdefaultencoding('utf8')import cmTestRunSimpleimport mathimport numpy as npimport scipy.interpolatefrom collections import namedtuplefrom Constants import *# Interpolation tables for determining mean front angle (inner & outer wheels) based on steering wheel angle# steering wheel angle in rad# mean front angle in radSTEER_WHEEL_ANGLE = [  0.5,   1.0,   1.5,   2.0,   2.5,   3.0,   3.5,   4.0,   4.5,   5.0,   5.5,   6.0,   6.5,   7.0,   7.5,   8.0, 8.527]MEAN_FRONT_ANGLE  = [0.031, 0.064, 0.099, 0.133, 0.166, 0.198, 0.232, 0.266, 0.300, 0.335, 0.371, 0.408, 0.446, 0.486, 0.526, 0.568, 0.612]yInterp_meanAngle = scipy.interpolate.interp1d(STEER_WHEEL_ANGLE, MEAN_FRONT_ANGLE)CM_EGO_VEHICLE_VELOCITY     = [1,     2,     3,     4,     5,     6,     7,     8,     9,     9.4,   9.5,   10,    11,    12,    13,    14,     15,     16,     17,     18,     19,     20] # km/hCM_DECELERATION             = [1,     1,     1,     2,     2,     2,     2,     3,     3,     3,     4,     4,     4,     4,     4,     4,      4,      4,      4,      4,      4,      4] # m/s^2, decelaration for the vehicle stopping maneuvers# These work only when the driving maneuver is set as VelControl (Speed Control) for forwards, not IPG DriverCM_STOP_DIST_FWD            = [0.107, 0.285, 0.548, 0.551, 0.783, 1.053, 1.347, 1.282, 1.553, 1.665, 2.776, 2.972, 3.378, 3.802, 4.242, 4.703,  5.184,  5.693,  6.158,  6.726,  7.286,  7.858] # m, distance required for stopping the forwards driving ego vehicleCM_STOP_DIST_BWD            = [0.000, 0.177, 0.388, 0.394, 0.593, 0.821, 1.088, 1.016, 1.252, 1.356, 1.114, 1.220, 3.222, 3.630, 4.063, 4.513,  4.984,  5.477,  5.999,  6.531,  7.058,  7.553] # m, distance required for stopping the backwards driving ego vehicleyInterpDeceleration         = scipy.interpolate.interp1d(CM_EGO_VEHICLE_VELOCITY, CM_DECELERATION, fill_value='extrapolate')yInterpStopDistFwd          = scipy.interpolate.interp1d(CM_EGO_VEHICLE_VELOCITY, CM_STOP_DIST_FWD, fill_value='extrapolate')yInterpStopDistBwd          = scipy.interpolate.interp1d(CM_EGO_VEHICLE_VELOCITY, CM_STOP_DIST_BWD, fill_value='extrapolate')laneWidth     = 0egoStartX     = 0egoStartY     = 0#====================================================================# Test Factories#====================================================================def init(testRun):    global laneWidth, egoStartX, egoStartY        tempList = testRun.getValues("Road.Link.0.LaneSection.0.LaneR.0 = ")    laneWidth = float(tempList[1])    tempList = testRun.getValues("Road.VhclStartPos = ")    egoStartX = float(tempList[0])    egoStartY = float(tempList[1])        def FactoryStaticPole(testRun, vEgo, steerWheelAng, collisionPoint, drivingTime=P_drivingTime, switchLSCA="ON", thetaOff=0):    global laneWidth, egoStartX, egoStartY        # rMin - inner radius (inner rear wheel)    # rMax - outer radius (front corner, opposite obstacle side)    # rColl - collision radius    # meanFrontAng - angle on the front axle middle (a mean between inner and outer front wheels' angles)    # theta - angle corresponding to the arc circle described by drivenDist        drivenDist = max(abs(vEgo) / 3.6 * drivingTime, P_minDrivingDist)        if vEgo < 0: # driving backwards        backwardsDriving = True        drivenDist += EGO_OVERHANG    else:        backwardsDriving = False        drivenDist += EGO_LENGTH - EGO_OVERHANG        if abs(steerWheelAng) < 0.5: # if the steering wheel is turned for less than 30°, consider straight driving        straightDriving = True        obstX = egoStartX + np.sign(vEgo) * (drivenDist) + EGO_OVERHANG        obstY = (egoStartY - (laneWidth / 2)) + (EGO_WIDTH / 2) - collisionPoint * EGO_WIDTH # a collision point of 0 will hit the vehicle on the driver side corners    else:        straightDriving = False        meanFrontAng = np.sign(steerWheelAng) * yInterp_meanAngle(abs(steerWheelAng))        rotationCenterX = 0        rotationCenterY = EGO_WHEELBASE / math.tan(meanFrontAng)                dist = abs(rotationCenterY) # the distance between the middle of the rear axle and rotationCenter        rMin = dist - EGO_WIDTH / 2        rMax = math.sqrt((EGO_LENGTH - EGO_OVERHANG)**2 + (dist + EGO_WIDTH / 2)**2)        rColl = rMin + collisionPoint * (rMax - rMin)        theta = drivenDist / ((rMax + rMin) / 2) # drivenDist is measured from the middle of ego vehicle                rotationCenterX += egoStartX + EGO_OVERHANG        rotationCenterY = np.sign(steerWheelAng) * dist + (egoStartY - (laneWidth / 2))        obstOffX = rColl * math.sin(theta)        obstOffY = rColl * math.cos(theta)        tempList = testRun.getValues("Traffic.1.Basics.Dimension = ")        obstRad = float(tempList[0]) / 2        obstX = round(rotationCenterX + np.sign(vEgo) * obstOffX - obstRad, 3)        obstY = round(rotationCenterY - np.sign(steerWheelAng) * obstOffY, 3)        if vEgo < 0: # driving backwards        testRun.addReplacement("DrivMan.3.Info = ", "Drive Backwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Backward 2.0 " + str(vEgo))    else:        testRun.addReplacement("DrivMan.3.Info = ", "Drive Forwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Driver 1 0.0 " + str(vEgo)) # IPG Driver            if straightDriving:        testRun.addReplacement("	DVAwr DM.Steer.Ang Abs -1 ", "0")        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.Distance >= " + str(round(drivenDist, 3)) + " ? ManJump(\"END\")")    else:        testRun.addReplacement("	DVAwr DM.Steer.Ang Abs -1 ", str(steerWheelAng))        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval abs(Vhcl.Yaw) >= " + str(round(theta + thetaOff, 3)) + " ? ManJump(\"END\")")    testRun.addReplacement("Traffic.1.Init.Road = ", str(obstX) + " " + str(obstY))        if switchLSCA == "ON":        testRun.addReplacement("	Eval first() ? AP.lscaDisabled_nu = ", "($LscaDisabled=0)")                def FactoryStaticObstacle(testRun, vEgo, collisionPoint, steerWheelAng=0, obstacle="adult"):    global laneWidth, egoStartX, egoStartY        tempList = testRun.getValues("Road.Route.0.Length = ")    routeLength = float(tempList[0])    routeMiddle = routeLength / 2        drivenDist = max(abs(vEgo) / 3.6 * P_drivingTime, P_minDrivingDist + 2)        obstAng = 0    if vEgo < 0: # driving backwards        testRun.addReplacement("DrivMan.3.Info = ", "Drive Backwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Backward 2.0 " + str(abs(vEgo)))        endTrigger = round(routeMiddle - 5, 3)        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad <= " + str(endTrigger) + " ? ManJump(\"END\")")                egoStartX = routeMiddle + drivenDist        obstAng += 180    else:        testRun.addReplacement("DrivMan.3.Info = ", "Drive Forwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Driver 1 0.0 " + str(vEgo)) # IPG Driver        endTrigger = round(routeMiddle + 5, 3)        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad >= " + str(endTrigger) + " ? ManJump(\"END\")")                egoStartX = routeMiddle - VHCL_SROAD_STARTOFF - drivenDist    # ego vehicle steering wheel    testRun.addReplacement("	DVAwr DM.Steer.Ang Abs -1 ", str(steerWheelAng))    # ego vehicle start position    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        # obstacle 3D model    obstModel = ""    obstContour = ""    if obstacle == "adult":        obstModel = "3D/People/Pedestrian_Male_Casual_01.manim"        obstContour = "\n\t0.000 0.000\n\t0.000 0.275\n\t0.330 0.275\n\t0.330 0.000"        obstDescription = "Pedestrian"        obstClass = "People"        latOff = 0    elif obstacle == "vehicle":        obstModel = "VW_Passat_B8_Variant_noWheels_rotated_black.obj"        obstContour = "\n\t0.000 0.000\n\t0.050 0.500\n\t0.120 0.685\n\t0.250 0.770\n\t0.740 0.916\n\t4.350 0.916\n\t4.500 0.850\n\t4.767 0.500\n\t4.767 0.000"        obstDescription = "Vehicle"        obstClass = "Car"        latOff = 0.5        testRun.addReplacement("Traffic.1.Info = ", obstDescription)    testRun.addReplacement("Traffic.1.Movie.Geometry = ", obstModel)    testRun.addReplacement("Traffic.1.Basics.Contour:", obstContour)    testRun.addReplacement("Traffic.1.ObjectClass = ", obstClass)    testRun.addReplacement("Traffic.1.Init.Orientation = 0.0 0.0 ", str(obstAng))        # due to lateral deviations of the ego vehicle during movement, shifting the obstacles is required    curveLatOffDict = {        -9.9 : 0.15,        -5   : 0.30,        -2   : 0.15,        2    : -0.30,        5    : -0.30,        9.9  : -0.30    }    curveLatOff = 0    if steerWheelAng != 0:        # change curveLatOff sign based on turn direction        curveLatOff = curveLatOffDict[vEgo]            obstX = routeMiddle    obstY = 0    if collisionPoint == "FR" or collisionPoint == "BR":        obstY = (-1) * EGO_WIDTH / 2        obstY -= latOff    elif collisionPoint == "FL" or collisionPoint == "BL":        obstY = EGO_WIDTH / 2        obstY += latOff    obstY += curveLatOff        testRun.addReplacement("Traffic.1.Init.Road = ", str(obstX) + " " + str(obstY))                def FactoryLateralPedestrian(testRun, vEgo, vPed, collisionPoint, roadType="straight", pedType="adult"):    global laneWidth, egoStartX, egoStartY        tempList = testRun.getValues("Road.Route.0.Length = ")    routeLength = float(tempList[0])        dictKeyType = namedtuple("dictKeyType", "vEgo vPed collPoint")    dictDefType = namedtuple("dictDefType", "endCondOff egoStartOff pedStartOff")    # due to different behavior in the ego vehicle reaching target velocity (rise time, response time, overshoot) hardcoded values are used for the timings of the pedestrian movement to yield more accurate use cases    # equations are used for collision with static objects    offsetDictStraightFwd = {        dictKeyType( 2, 2, "FL")    :   dictDefType(35.3, 25, 12),        dictKeyType( 2, 2, "FC")    :   dictDefType(36.0, 25, 12),        dictKeyType( 2, 2, "FR")    :   dictDefType(37.0, 25, 12),        dictKeyType( 2, 4, "FL")    :   dictDefType(37.1, 25, 12),        dictKeyType( 2, 4, "FC")    :   dictDefType(37.4, 25, 12),        dictKeyType( 2, 4, "FR")    :   dictDefType(37.8, 25, 12),        dictKeyType( 5, 2, "FL")    :   dictDefType(25.2, 20, 10),        dictKeyType( 5, 2, "FC")    :   dictDefType(27.0, 20, 10),        dictKeyType( 5, 2, "FR")    :   dictDefType(29.2, 20, 10),        dictKeyType( 5, 4, "FL")    :   dictDefType(31.7, 20, 10),        dictKeyType( 5, 4, "FC")    :   dictDefType(32.8, 20, 10),        dictKeyType( 5, 4, "FR")    :   dictDefType(33.9, 20, 10),        dictKeyType(9.9, 2, "FL")   :   dictDefType(12.0,  5, 10),        dictKeyType(9.9, 2, "FC")   :   dictDefType(15.5,  5, 10),        dictKeyType(9.9, 2, "FR")   :   dictDefType(19.0,  5, 10),        dictKeyType(9.9, 4, "FL")   :   dictDefType(24.8,  5, 10),        dictKeyType(9.9, 4, "FC")   :   dictDefType(27.0,  5, 10),        dictKeyType(9.9, 4, "FR")   :   dictDefType(29.2,  5, 10)    }        offsetDictCurvedFwd = {        dictKeyType( 2, 2, "FL")    :   dictDefType(29.5, 24, 12),        dictKeyType( 2, 2, "FC")    :   dictDefType(30.5, 24, 12),        dictKeyType( 2, 2, "FR")    :   dictDefType(31.5, 24, 12),        dictKeyType( 2, 4, "FL")    :   dictDefType(31.0, 24, 12),        dictKeyType( 2, 4, "FC")    :   dictDefType(31.7, 24, 12),        dictKeyType( 2, 4, "FR")    :   dictDefType(32.3, 24, 12),        dictKeyType( 5, 2, "FL")    :   dictDefType(24.0, 15, 12),        dictKeyType( 5, 2, "FC")    :   dictDefType(27.0, 15, 12),        dictKeyType( 5, 2, "FR")    :   dictDefType(29.0, 15, 12),        dictKeyType( 5, 4, "FL")    :   dictDefType(28.5, 15, 12),        dictKeyType( 5, 4, "FC")    :   dictDefType(30.0, 15, 12),        dictKeyType( 5, 4, "FR")    :   dictDefType(31.0, 15, 12),        dictKeyType(9.9, 2, "FL")   :   dictDefType( 8.5,  0, 10),        dictKeyType(9.9, 2, "FC")   :   dictDefType(13.0,  0, 10),        dictKeyType(9.9, 2, "FR")   :   dictDefType(16.0,  0, 10),        dictKeyType(9.9, 4, "FL")   :   dictDefType(20.5,  0, 10),        dictKeyType(9.9, 4, "FC")   :   dictDefType(22.8,  0, 10),        dictKeyType(9.9, 4, "FR")   :   dictDefType(24.7,  0, 10)    }        offsetDictStraightBwd = {        dictKeyType( -2, 2, "BL")    :   dictDefType(47.8, 46, 12),        dictKeyType( -2, 2, "BC")    :   dictDefType(47.0, 46, 12),        dictKeyType( -2, 2, "BR")    :   dictDefType(46.0, 46, 12),        dictKeyType( -2, 4, "BL")    :   dictDefType(46.0, 46, 12),        dictKeyType( -2, 4, "BC")    :   dictDefType(45.6, 46, 12),        dictKeyType( -2, 4, "BR")    :   dictDefType(45.2, 46, 12),        dictKeyType( -5, 2, "BL")    :   dictDefType(53.3, 54, 12),        dictKeyType( -5, 2, "BC")    :   dictDefType(51.1, 54, 12),        dictKeyType( -5, 2, "BR")    :   dictDefType(49.0, 54, 12),        dictKeyType( -5, 4, "BL")    :   dictDefType(48.8, 54, 12),        dictKeyType( -5, 4, "BC")    :   dictDefType(47.8, 54, 12),        dictKeyType( -5, 4, "BR")    :   dictDefType(46.8, 54, 12),        dictKeyType(-9.9, 2, "BL")   :   dictDefType(63.0, 70, 12),        dictKeyType(-9.9, 2, "BC")   :   dictDefType(58.5, 70, 12),        dictKeyType(-9.9, 2, "BR")   :   dictDefType(54.0, 70, 12),        dictKeyType(-9.9, 4, "BL")   :   dictDefType(53.7, 70, 12),        dictKeyType(-9.9, 4, "BC")   :   dictDefType(51.7, 70, 12),        dictKeyType(-9.9, 4, "BR")   :   dictDefType(49.4, 70, 12)    }        offsetDictCurvedBwd = {        dictKeyType( -2, 2, "BL")    :   dictDefType(41.5, 40, 12),        dictKeyType( -2, 2, "BC")    :   dictDefType(40.6, 40, 12),        dictKeyType( -2, 2, "BR")    :   dictDefType(39.7, 40, 12),        dictKeyType( -2, 4, "BL")    :   dictDefType(39.8, 40, 12),        dictKeyType( -2, 4, "BC")    :   dictDefType(39.3, 40, 12),        dictKeyType( -2, 4, "BR")    :   dictDefType(38.7, 40, 12),        dictKeyType( -5, 2, "BL")    :   dictDefType(45.5, 48, 12),        dictKeyType( -5, 2, "BC")    :   dictDefType(43.5, 48, 12),        dictKeyType( -5, 2, "BR")    :   dictDefType(41.5, 48, 12),        dictKeyType( -5, 4, "BL")    :   dictDefType(41.8, 48, 12),        dictKeyType( -5, 4, "BC")    :   dictDefType(40.9, 48, 12),        dictKeyType( -5, 4, "BR")    :   dictDefType(39.5, 48, 12),        dictKeyType(-9.9, 2, "BL")   :   dictDefType(52.0, 62, 12),        dictKeyType(-9.9, 2, "BC")   :   dictDefType(48.0, 62, 12),        dictKeyType(-9.9, 2, "BR")   :   dictDefType(44.0, 62, 12),        dictKeyType(-9.9, 4, "BL")   :   dictDefType(45.0, 62, 12),        dictKeyType(-9.9, 4, "BC")   :   dictDefType(43.0, 62, 12),        dictKeyType(-9.9, 4, "BR")   :   dictDefType(40.7, 62, 12)    }        # call with e.g. offsetDictStraightFwd[(vEgo, vPed, collisionPoint)].endCondOff        offsetDict = {}    if vEgo < 0: # driving backwards        if roadType == "straight":            offsetDict = offsetDictStraightBwd                        tempList = testRun.getValues("Traffic.N = ")            trafficObjectsNo = int(tempList[0])            if trafficObjectsNo == 3: # check if there is a third traffic object (assume it is a parked vehicle), besides odometry arrow and pedestrian                tempList = testRun.getValues("Traffic.2.Init.Road = ")                parkVehX = 41.233 # routeLength / 2 + (routeLength / 2 - parkVehX + parkVehLength)                parkVehY = float(tempList[1])                testRun.addReplacement("Traffic.2.Init.Road = ", str(parkVehX) + " " + str(parkVehY))        else:            offsetDict = offsetDictCurvedBwd    else:        if roadType == "straight":            offsetDict = offsetDictStraightFwd        else:            offsetDict = offsetDictCurvedFwd        routeMiddle = routeLength / 2    if vEgo < 0: # driving backwards        testRun.addReplacement("DrivMan.3.Info = ", "Drive Backwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Backward 2.0 " + str(abs(vEgo)))        endTrigger = round(routeMiddle - 5, 3)        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad <= " + str(endTrigger) + " ? ManJump(\"END\")")    else:        testRun.addReplacement("DrivMan.3.Info = ", "Drive Forwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Driver 1 0.0 " + str(vEgo)) # IPG Driver        endTrigger = round(routeMiddle + 5, 3)        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad >= " + str(endTrigger) + " ? ManJump(\"END\")")            # pedestrian maneuvers    testRun.addReplacement("Traffic.1.Man.1.LongDyn = v ", str(vPed))    testRun.addReplacement("Traffic.1.Man.2.LongDyn = v ", str(vPed))    if vEgo < 0: # driving backwards        testRun.addReplacement("Traffic.1.Man.0.EndCondition = Vhcl.sRoad", "<=" + str(offsetDict[(vEgo, vPed, collisionPoint)].endCondOff))    else:        testRun.addReplacement("Traffic.1.Man.0.EndCondition = Vhcl.sRoad", ">=" + str(offsetDict[(vEgo, vPed, collisionPoint)].endCondOff))         egoStartX = offsetDict[(vEgo, vPed, collisionPoint)].egoStartOff    pedStartX = offsetDict[(vEgo, vPed, collisionPoint)].pedStartOff        # ego vehicle start position    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        # pedestrian start position    pedStartX = round(pedStartX, 3)    pedStartY = 0.0    testRun.addReplacement("Traffic.1.Init.Road = ", str(pedStartX) + " " + str(pedStartY))        # pedestrian 3D model    pedModel = ""    if pedType == "adult":        pedModel = "3D/People/Pedestrian_Male_Casual_01.manim"    elif pedType == "child":        pedModel = "3D/People/Pedestrian_Female_Child_01_115c"    testRun.addReplacement("Traffic.1.Movie.Geometry = ", pedModel)        def FactoryLongitudinalPedestrian(testRun, vEgo, vPed, collisionPoint, scenarioEndOff=0, scenarioEndTime=0, pedFixedStartOffX=0):    global laneWidth, egoStartX, egoStartY        tempList = testRun.getValues("Road.Route.0.Length = ")    routeLength = float(tempList[0])    tempList = testRun.getValues("Traffic.1.Basics.Dimension = ")    pedLength = float(tempList[0])    pedWidth = float(tempList[1])        egoPedDist = 0    pedStartX = 0    pedStartY = 0    pedStartPsi = 0    if abs(vEgo) <= 2:        egoPedDist = 10    elif abs(vEgo) <= 5:        egoPedDist = 15    else:        egoPedDist = 30        if vEgo < 0: # driving backwards        egoStartX = routeLength - 5        testRun.addReplacement("DrivMan.3.Info = ", "Drive Backwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Backward 2.0 " + str(abs(vEgo)))        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad <= Traffic.Ped.sRoad - " + str(scenarioEndOff) + " ? ManJump(\"END\")")    else:        egoStartX = 5        testRun.addReplacement("DrivMan.3.Info = ", "Drive Forwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Driver 1 0.0 " + str(vEgo)) # IPG Driver        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad >= Traffic.Ped.sRoad + " + str(scenarioEndOff) + " ? ManJump(\"END\")")        if scenarioEndTime > 0:        testRun.addReplacementBefore("DrivMan.3.Cmds:", "DrivMan.3.TimeLimit = " + str(scenarioEndTime))        # pedestrian maneuvers    testRun.addReplacement("Traffic.1.Man.1.LongDyn = v ", str(vPed))    testRun.addReplacement("Traffic.1.Man.2.LongDyn = v ", str(vPed))            if vPed < 0: # orient the pedestrian in its moving direction        pedStartPsi = 180            if np.sign(vEgo) != np.sign(vPed):        egoPedDist += 2.0 * abs(vEgo) + abs(vPed) # increase longitudinal offset when the pedestrian is moving towards the ego vehicle    else:        if abs(vEgo - vPed) <= 1:             egoPedDist -= 5 * abs(vEgo) / 5 # decrease longitudinal offset when ego vehicle and pedestrian move in the same direction with similar velocities        if pedFixedStartOffX == 0:        pedStartX = egoStartX + np.sign(vEgo) * egoPedDist    else:        if vEgo < 0: # driving backwards            pedStartX = egoStartX - pedFixedStartOffX - pedLength        else:            pedStartX = egoStartX + EGO_LENGTH + pedFixedStartOffX    pedStartY = collisionPoint            # ego vehicle start position    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        # pedestrian start position    pedStartX = round(pedStartX, 3)    pedStartY = round(pedStartY, 3)    testRun.addReplacement("Traffic.1.Init.Road = ", str(pedStartX) + " " + str(pedStartY))    testRun.addReplacement("Traffic.1.Init.Orientation = 0.0 0.0 ", str(pedStartPsi))        def FactoryStaticBoxes(testRun, vEgo, latOff, roadType="straight"):    global laneWidth, egoStartX, egoStartY        tempList = testRun.getValues("Road.Route.0.Length = ")    routeLength = float(tempList[0])    drivingTime = 10 # s # duration until ego vehicle reaches the static boxes    tempList = testRun.getValues("Traffic.1.Basics.Dimension = ")    boxLength = float(tempList[0])    boxWidth = float(tempList[1])        if vEgo < 0: # driving backwards        egoStartX = routeLength / 2 + (abs(vEgo) / 3.6) * drivingTime        testRun.addReplacement("DrivMan.3.Info = ", "Drive Backwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Backward 2.0 " + str(abs(vEgo)))        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad <= " + str(routeLength / 2 - 3) + " ? ManJump(\"END\")")    else:        egoStartX = routeLength / 2 - (vEgo / 3.6) * drivingTime - VHCL_SROAD_STARTOFF        testRun.addReplacement("DrivMan.3.Info = ", "Drive Forwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Driver 1 0.0 " + str(vEgo)) # IPG Driver        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad >= " + str(routeLength / 2 + 3) + " ? ManJump(\"END\")")            # ego vehicle start position    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        # due to lateral deviations of the ego vehicle during movement, shifting the obstacles is required    curveLatOffDict = {        -9.9 : 0.15,        -5   : 0.30,        -2   : 0.00,        2    : 0.20,        5    : 0.20,        9.9  : 0.20    }        # boxes position    boxStartX = routeLength / 2 - boxLength / 2    drivingTubeCurveOff = 0    curveLatOff = 0    if roadType != "straight":        # TODO: calculate the driving tube width based on the steering wheel angle        drivingTubeCurveOff = 0.3        # TODO: update getValues to work with string        # tempList = testRun.getValues("Road.Link.0.Seg.0.Type = ")        # change curveLatOff sign based on turn direction        curveLatOff = curveLatOffDict[vEgo]    boxStartY = EGO_WIDTH_MIRRORS / 2 + boxWidth / 2 + latOff + drivingTubeCurveOff    boxStartX = round(boxStartX, 3)    boxStartY = round(boxStartY, 3)    testRun.addReplacement("Traffic.1.Init.Road = ", str(boxStartX) + " " + str(boxStartY + curveLatOff))    testRun.addReplacement("Traffic.2.Init.Road = ", str(boxStartX) + " " + str((-1) * boxStartY + curveLatOff))    def FactoryLateralPedestrianAndStop(testRun, vEgo, latOff, roadType="straight"):    global laneWidth, egoStartX, egoStartY        tempList = testRun.getValues("Road.Route.0.Length = ")    routeLength = float(tempList[0])    tempList = testRun.getValues("Road.Route.1.Length = ")    pedRouteLength = float(tempList[0])    drivingTime = 10 # s # duration until ego vehicle reaches the middle of the junction    tempList = testRun.getValues("Traffic.1.Basics.Dimension = ")    pedLength = float(tempList[0])    pedWidth = float(tempList[1])        if vEgo < 0: # driving backwards        egoStartX = routeLength / 2 + (abs(vEgo) / 3.6) * drivingTime        testRun.addReplacement("DrivMan.3.Info = ", "Drive Backwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Backward 2.0 " + str(abs(vEgo)))        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad <= " + str(routeLength / 2 + VHCL_SROAD_STARTOFF - 1.5) + " ? ManJump(\"END\")")    else:        egoStartX = routeLength / 2 - (vEgo / 3.6) * drivingTime - EGO_LENGTH        testRun.addReplacement("DrivMan.3.Info = ", "Drive Forwards")        testRun.addReplacement("DrivMan.3.LongDyn = ", "Driver 1 0.0 " + str(vEgo)) # IPG Driver        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad >= " + str(routeLength / 2 - (EGO_LENGTH - VHCL_SROAD_STARTOFF) + 1.5) + " ? ManJump(\"END\")")            # ego vehicle start position    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        # due to lateral deviations of the ego vehicle during movement, shifting the obstacles is required    curveLatOffDict = {        -9.9 : 0.15,        -5   : 0.30,        -2   : 0.00,        2    : 0.05,        5    : 0.05,        9.9  : 0.20    }        curveLatOff = 0    if roadType != "straight":        # TODO: update getValues to work with string        # tempList = testRun.getValues("Road.Link.0.Seg.0.Type = ")        # change curveLatOff sign based on turn direction        curveLatOff = curveLatOffDict[vEgo]        # move pedestrian    pedTrigger = pedRouteLength / 2 - EGO_WIDTH_MIRRORS / 2 - pedLength / 2 - latOff - curveLatOff    pedTrigger = round(pedTrigger, 3)    testRun.addReplacement("	# Move pedestrian", "\n\tEval Traffic.Ped.sRoad < " + str(pedTrigger) + " ? Traffic.Ped.LongVel = Vhcl.v" + \                                                    "\n\tEval Traffic.Ped.sRoad >= " + str(pedTrigger) + " ? Traffic.Ped.LongVel = 0")        # pedestrian start position        pedStartX = pedRouteLength / 2 - (abs(vEgo) / 3.6) * drivingTime - pedLength    pedStartX = round(pedStartX, 3)    testRun.addReplacement("Traffic.1.Init.Road = ", str(pedStartX) + " 0.0")        def FactoryParkingOutLongitudinalPedestrian(testRun, vEgo, vPed, collisionPoint, pedType="adult"):    global laneWidth, egoStartX, egoStartY        tempList = testRun.getValues("Road.Route.0.Length = ")    routeLength = float(tempList[0])        dictKeyType = namedtuple("dictKeyType", "vEgo vPed collPoint")    dictDefType = namedtuple("dictDefType", "egoStartOff pedStartOff pedLatOff egoRoute")    # due to different behavior in the ego vehicle reaching target velocity (rise time, response time, overshoot) hardcoded values are used for the timings of the pedestrian movement to yield more accurate use cases    # equations are used for collision with static objects    offsetDictStraightFwd = {        dictKeyType( 2, 2, "LF")   :   dictDefType(33, 35.0, -2, "Route_1"),        dictKeyType( 2, 2, "LC")   :   dictDefType(33, 34.0, -2, "Route_1"),        dictKeyType( 2, 2, "LB")   :   dictDefType(33, 33.0, -2, "Route_1"),        dictKeyType( 2, 2, "RF")   :   dictDefType(33, 35.0,  2, "Route_2"),        dictKeyType( 2, 2, "RC")   :   dictDefType(33, 34.0,  2, "Route_2"),        dictKeyType( 2, 2, "RB")   :   dictDefType(33, 33.0,  2, "Route_2"),        dictKeyType( 2, 5, "LF")   :   dictDefType(33, 24.5, -2, "Route_1"),        dictKeyType( 2, 5, "LC")   :   dictDefType(33, 22.8, -2, "Route_1"),        dictKeyType( 2, 5, "LB")   :   dictDefType(33, 20.3, -2, "Route_1"),        dictKeyType( 2, 5, "RF")   :   dictDefType(33, 24.5,  2, "Route_2"),        dictKeyType( 2, 5, "RC")   :   dictDefType(33, 22.8,  2, "Route_2"),        dictKeyType( 2, 5, "RB")   :   dictDefType(33, 20.3,  2, "Route_2"),        dictKeyType( 5, 2, "LF")   :   dictDefType(25, 35.4, -2, "Route_1"),        dictKeyType( 5, 2, "LC")   :   dictDefType(25, 34.6, -2, "Route_1"),        dictKeyType( 5, 2, "LB")   :   dictDefType(25, 34.0, -2, "Route_1"),        dictKeyType( 5, 2, "RF")   :   dictDefType(25, 35.4,  2, "Route_2"),        dictKeyType( 5, 2, "RC")   :   dictDefType(25, 34.6,  2, "Route_2"),        dictKeyType( 5, 2, "RB")   :   dictDefType(25, 34.0,  2, "Route_2"),        dictKeyType( 5, 5, "LF")   :   dictDefType(25, 25.5, -2, "Route_1"),        dictKeyType( 5, 5, "LC")   :   dictDefType(25, 24.5, -2, "Route_1"),        dictKeyType( 5, 5, "LB")   :   dictDefType(25, 23.5, -2, "Route_1"),        dictKeyType( 5, 5, "RF")   :   dictDefType(25, 25.5,  2, "Route_2"),        dictKeyType( 5, 5, "RC")   :   dictDefType(25, 24.5,  2, "Route_2"),        dictKeyType( 5, 5, "RB")   :   dictDefType(25, 23.5,  2, "Route_2")    }        offsetDictStraightBwd = {        dictKeyType( -2, -2, "LF")   :   dictDefType(64, 69.1, -2, "Route_1"),        dictKeyType( -2, -2, "LC")   :   dictDefType(64, 67.7, -2, "Route_1"),        dictKeyType( -2, -2, "LB")   :   dictDefType(64, 66.7, -2, "Route_1"),        dictKeyType( -2, -2, "RF")   :   dictDefType(64, 69.1,  2, "Route_2"),        dictKeyType( -2, -2, "RC")   :   dictDefType(64, 67.7,  2, "Route_2"),        dictKeyType( -2, -2, "RB")   :   dictDefType(64, 66.7,  2, "Route_2"),        dictKeyType( -2, -5, "LF")   :   dictDefType(64, 86.5, -2, "Route_1"),        dictKeyType( -2, -5, "LC")   :   dictDefType(64, 83.0, -2, "Route_1"),        dictKeyType( -2, -5, "LB")   :   dictDefType(64, 80.0, -2, "Route_1"),        dictKeyType( -2, -5, "RF")   :   dictDefType(64, 86.5,  2, "Route_2"),        dictKeyType( -2, -5, "RC")   :   dictDefType(64, 83.0,  2, "Route_2"),        dictKeyType( -2, -5, "RB")   :   dictDefType(64, 80.0,  2, "Route_2"),        dictKeyType( -5, -2, "LF")   :   dictDefType(75, 67.7, -2, "Route_1"),        dictKeyType( -5, -2, "LC")   :   dictDefType(75, 67.2, -2, "Route_1"),        dictKeyType( -5, -2, "LB")   :   dictDefType(75, 66.7, -2, "Route_1"),        dictKeyType( -5, -2, "RF")   :   dictDefType(75, 67.7,  2, "Route_2"),        dictKeyType( -5, -2, "RC")   :   dictDefType(75, 67.2,  2, "Route_2"),        dictKeyType( -5, -2, "RB")   :   dictDefType(75, 66.7,  2, "Route_2"),        dictKeyType( -5, -5, "LF")   :   dictDefType(75, 81.5, -2, "Route_1"),        dictKeyType( -5, -5, "LC")   :   dictDefType(75, 80.2, -2, "Route_1"),        dictKeyType( -5, -5, "LB")   :   dictDefType(75, 79.0, -2, "Route_1"),        dictKeyType( -5, -5, "RF")   :   dictDefType(75, 81.5,  2, "Route_2"),        dictKeyType( -5, -5, "RC")   :   dictDefType(75, 80.2,  2, "Route_2"),        dictKeyType( -5, -5, "RB")   :   dictDefType(75, 79.0,  2, "Route_2")    }        # call with e.g. offsetDictStraightFwd[(vEgo, vPed, collisionPoint)].egoStartOff        offsetDict = {}    routeMiddle = routeLength / 2    if vEgo < 0: # driving backwards        offsetDict = offsetDictStraightBwd        testRun.addReplacement("DrivMan.2.Info = ", "Drive Backwards")        testRun.addReplacement("DrivMan.2.LongDyn = ", "Backward 2.0 " + str(abs(vEgo)))        endTrigger = round(routeMiddle + 5, 3)        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad <= " + str(endTrigger) + " ? ManJump(\"END\")")    else:        offsetDict = offsetDictStraightFwd        testRun.addReplacement("DrivMan.2.Info = ", "Drive Forwards")        testRun.addReplacement("DrivMan.2.LongDyn = ", "Driver 1 0.0 " + str(vEgo)) # IPG Driver        endTrigger = round(routeMiddle, 3)        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad >= " + str(endTrigger) + " ? ManJump(\"END\")")            # pedestrian maneuvers    testRun.addReplacement("Traffic.1.Man.1.LongDyn = v ", str(vPed))    testRun.addReplacement("Traffic.1.Man.2.LongDyn = v ", str(vPed))        egoStartX = offsetDict[(vEgo, vPed, collisionPoint)].egoStartOff    egoRoute  = offsetDict[(vEgo, vPed, collisionPoint)].egoRoute    pedStartX = offsetDict[(vEgo, vPed, collisionPoint)].pedStartOff    pedStartY = offsetDict[(vEgo, vPed, collisionPoint)].pedLatOff        # ego vehicle start position    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))    testRun.addReplacement("Road.VhclRoute = ", egoRoute)    testRun.addReplacement("Road.RouteId = ", egoRoute[-1])        # pedestrian start position    pedStartX = round(pedStartX, 3)    pedStartY = round(pedStartY, 3)    testRun.addReplacement("Traffic.1.Init.Road = ", str(pedStartX) + " " + str(pedStartY))        # pedestrian 3D model    pedModel = ""    if pedType == "adult":        pedModel = "3D/People/Pedestrian_Male_Casual_01.manim"    elif pedType == "child":        pedModel = "3D/People/Pedestrian_Female_Child_01_115c"    testRun.addReplacement("Traffic.1.Movie.Geometry = ", pedModel)        def FactoryDriveAndStop(testRun, vEgo, distToObst=0.1):    global laneWidth, egoStartX, egoStartY        dist = abs(vEgo) / 3.6 * 10        tempList = testRun.getValues("Traffic.1.Init.Road = ")    curbStartX = float(tempList[0])    tempList = testRun.getValues("Traffic.1.Basics.Dimension = ")    curbEndX = float(tempList[0]) + curbStartX # TODO: change equation to account for orientation in case of curved road        decel = int(yInterpDeceleration(abs(vEgo)))        if vEgo < 0:        # distDrive = float(dist - yInterpStopDistBwd(vEgo))        # egoStartX = curbEndX + dist        stopDist = float(yInterpStopDistBwd(abs(vEgo)))        distDrive = dist - stopDist        egoStartX = curbEndX + dist + distToObst        trigger = curbEndX + stopDist + distToObst + VHCL_SROAD_STARTOFF        trigger = round(trigger, 3)        testRun.addReplacement("DrivMan.2.Info = ", "Drive Backwards")        testRun.addReplacement("DrivMan.2.LongDyn = ", "Backward 2.0 " + str(abs(vEgo)))        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad <= " + str(trigger) + " ? ManJump(\"+1\")")    else:            stopDist = float(yInterpStopDistFwd(vEgo)) # stopping distance value based on ego vehicle velocity        distDrive = dist - stopDist        egoStartX = curbStartX - dist - distToObst - EGO_LENGTH        trigger = curbStartX - stopDist - distToObst - (EGO_LENGTH - VHCL_SROAD_STARTOFF) # (EGO_LENGTH - VHCL_SROAD_STARTOFF) is subtracted so the front bumper reaches the collision point at standstill        trigger = round(trigger, 3)        testRun.addReplacement("DrivMan.2.Info = ", "Drive Forwards")        testRun.addReplacement("DrivMan.2.LongDyn = VelControl ", str(vEgo) + " 0.0 1.0 0.0 1 0.0") # IPG Driver        testRun.addReplacement("	# Scanning with constant velocity complete", "\n\tEval Vhcl.sRoad >= " + str(trigger) + " ? ManJump(\"+1\")")            # deceleration value based on velocity    # testRun.addReplacement("DrivMan.3.LongDyn = Stop ", str(decel) + " 0")    testRun.addReplacement("DrivMan.3.LongDyn = Stop ", str(decel))            # ego vehicle start position    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        def FactoryMaxSpeedTH(testRun, vEgoTH):    global laneWidth, egoStartX, egoStartY        # TODO: check if TH is in mps and convert it to kph    if vEgoTH < 0:        testRun.addReplacement("DrivMan.2.LongDyn = ", "Backward 2.0 " + str(abs(vEgoTH + 0.5)))        testRun.addReplacement("DrivMan.3.LongDyn = ", "Backward 2.0 " + str(abs(vEgoTH + 0.5)))        testRun.addReplacement("DrivMan.4.LongDyn = ", "Backward 2.0 " + str(abs(vEgoTH - 0.5)))        testRun.addReplacement("DrivMan.5.LongDyn = ", "Backward 2.0 " + str(abs(vEgoTH - 0.5)))    else:        testRun.addReplacement("DrivMan.2.LongDyn = ", "Driver 1 0.0 " + str(abs(vEgoTH - 0.5)))        testRun.addReplacement("DrivMan.3.LongDyn = ", "Driver 1 0.0 " + str(abs(vEgoTH - 0.5)))        testRun.addReplacement("DrivMan.4.LongDyn = ", "Driver 1 0.0 " + str(abs(vEgoTH + 0.5)))        testRun.addReplacement("DrivMan.5.LongDyn = ", "Driver 1 0.0 " + str(abs(vEgoTH + 0.5)))            def FactoryDescription(testRun, useCase=1):    UCString = ""    if useCase == 1: # Activation Use Case        UCString = "1 (Use Case)"    else: # Non-Activation Use Case        UCString = "0 (Non-Use Case)"    testRun.addReplacement("	Non-/Use Case = ", UCString)    