#********************************************************************# System Imports#********************************************************************import sysimport imp
imp.reload(sys)# sys.setdefaultencoding('utf8')import cmTestRunSimpleimport mathimport numpy as npimport scipy.interpolatefrom collections import namedtuplefrom Constants import *A_egoVelocity     = [0, 14, 15, 35, 60, 90, 110, 300] # km/hA_egoGear         = [1,  1,  2,  3,  4,  5,   6,   6] # nuyInterp_egoGear   = scipy.interpolate.interp1d(A_egoVelocity, A_egoGear)# limTypeParamConfigType is named tuple containing for each limiter zone:# exists - if the limiter should be created# limType - limiter typelimConfigType = namedtuple("limConfigType", "exists limType")limHeight = {    "line"      : LIM_HEIGHT_LINE,    "curb_t"    : LIM_HEIGHT_CURBT,    "curb_tb"   : LIM_HEIGHT_CURBTB,    "curb_ntd"  : LIM_HEIGHT_CURBNTD,    "curb_nt"   : LIM_HEIGHT_CURBNT,    "wall"      : LIM_HEIGHT_WALL    }    CMSign        = 0laneWidth     = 0u_Rd          = 0v_Rd          = 0lim_P1_P_x    = 0lim_P2_P_x    = 0lim_H_x1      = 0lim_H_x2      = 0latVPark      = 0latHPark      = 0latHParkZone  = 0trafficObjIdx = 0scanDist      = 0#====================================================================# Test Factories#====================================================================def init(testRun, CarMakerSign=-1):    global lim_P1_P_x, lim_P2_P_x, latVPark, lim_H_x1, lim_H_x2, latHPark, latHParkZone, laneWidth, u_Rd, v_Rd, CMSign, trafficObjIdx, scanDist        CMSign = CarMakerSign    tempList = testRun.getValues("Road.Link.0.LaneSection.3.Start = ")    lim_P1_P_x = float(tempList[0])    tempList = testRun.getValues("Road.Link.0.LaneSection.2.Start = ")    lim_P2_P_x = float(tempList[0])    tempList = testRun.getValues("Road.Link.0.LaneSection.4.Start = ")    lim_H_x1 = float(tempList[0])    tempList = testRun.getValues("Road.Link.0.LaneSection.1.Start = ")    lim_H_x2 = float(tempList[0])    latHPark = lim_P1_P_x - lim_P2_P_x    latHParkZone = lim_H_x1 - lim_H_x2    if CMSign == -1:        tempList = testRun.getValues("Road.Link.0.LaneSection.1.LaneR.1 = ")        latVPark = float(tempList[1])    else:        tempList = testRun.getValues("Road.Link.0.LaneSection.1.LaneL.1 = ")        latVPark = float(tempList[1])    tempList = testRun.getValues("Road.Link.0.LaneSection.0.LaneR.0 = ")    laneWidth = float(tempList[1])    v_Rd = CMSign * laneWidth    tempList = testRun.getValues("Road.Link.0.LaneSection.3.Start = ")    u_Rd = float(tempList[0])    scanDist = P_scanDist        # Get the number of existing traffic objects    fillTrafficObjectIndex(testRun)        def getAngledScanStartPos(endX, endY, scanAng):    global CMSign, v_Rd, scanDist        psiRad = math.radians(-CMSign * scanAng)    limRoad = v_Rd / 2    if CMSign == 1:        limRoad += v_Rd        yDelta = CMSign * np.sign(scanAng) * math.sin(abs(psiRad)) * scanDist    startY = endY + yDelta        # if np.sign(scanAng) >= 0 and abs(startY) > abs(limRoad): # the middle of the ego vehicle should not go beyond v_Rd at the start of the scanning phase        # startY = limRoad        # yDelta = abs(startY - endY)        # scanDist = yDelta / math.sin(abs(psiRad))            xDelta = (scanDist + VHCL_SROAD_STARTOFF) * math.cos(abs(psiRad))        startPosEgoX = round(endX - xDelta, 3)    startPosEgoY = round(startY, 3)    scanDist = round(scanDist, 3)        return (startPosEgoX, startPosEgoY)def FactoryEgoVehicle(testRun, vEgo=10, latOff=0.5, scanAng=0):    global CMSign, laneWidth, lim_P1_P_x    # egoGear     = int(yInterp_egoGear(vEgo))        tempList = testRun.getValues("DrivMan.2.LongDyn = VelControl ")    tempList[0] = str(vEgo)    testRun.addReplacement("DrivMan.2.LongDyn = VelControl ", ' '.join(tempList))        tempList  = testRun.getValues("Road.Link.0.LaneSection.3.Start = ")    # # Finish scanning phase after P_scenarioEnd_s seconds have elapsed since the ego vehicle passed the parking spot    # stopDist = round(float(tempList[0]) + VHCL_SROAD_STARTOFF + P_scenarioEnd_s * (vEgo / 3.6), 3)    # Finish scanning phase after P_scenarioEnd_d meters have been traveled since the ego vehicle passed the parking spot    stopDist = round(float(tempList[0]) + VHCL_SROAD_STARTOFF + P_scenarioEnd_d, 3)    testRun.addReplacement("	Eval Vhcl.sRoad >= ", str(stopDist) + " ? ManJump(\"+2\")")        # This point must be crossed during the scanning phase    endX = lim_P1_P_x    endY = round(CMSign * (laneWidth / 2 - EGO_WIDTH / 2 - latOff), 3)    if CMSign == 1:        endY += v_Rd        tempList  = testRun.getValues("Road.VhclStartPos = ")    if scanAng == 0:        startX = endX - P_scanDist - VHCL_SROAD_STARTOFF        startY = endY        tempList[0] = str(startX)        tempList[1] = str(startY)    else:        (startX, startY) = getAngledScanStartPos(endX, endY, scanAng)        startAng = -CMSign * scanAng        tempList[0] = str(startX)        tempList[1] = str(startY)        tempList[2] = str(startAng)    testRun.addReplacement("Road.VhclStartPos = ", ' '.join(tempList))    def fillParkedVehicleData(testRun, idxParked, xOff, yOff, psiOff):    global CMSign    tempList = testRun.getValues("Traffic." + str(idxParked) + ".Init.Road = ")    x = float(tempList[0]) + xOff    y = float(tempList[1]) - CMSign * yOff    tempList = testRun.getValues("Traffic." + str(idxParked) + ".Init.Orientation = ")    psi = float(tempList[2]) - CMSign * psiOff        testRun.addReplacement("Traffic." + str(idxParked) + ".Init.Orientation = 0.0 0.0 ", str(psi))    testRun.addReplacement("Traffic." + str(idxParked) + ".Init.Road = ", str(x) + " " + str(y))    def FactoryParkedVehicles(testRun, xOffP1=0, yOffP1=0, psiOffP1=0, xOffP2=0, yOffP2=0, psiOffP2=0):    if xOffP1 != 0 or yOffP1 != 0 or psiOffP1 != 0:        fillParkedVehicleData(testRun, 0, xOffP1, yOffP1, psiOffP1)    if xOffP2 != 0 or yOffP2 != 0 or psiOffP2 != 0:        fillParkedVehicleData(testRun, 1, xOffP2, yOffP2, psiOffP2)                def getLimiterData(desc, height, basicOffset, limLatH, limLatV, limX, limY):    global trafficObjIdx    limLatH = round(limLatH, 3)    limLatV = round(limLatV, 3)        limStr =  "Traffic." + str(trafficObjIdx) + ".ObjectKind = StatWithName\n" + \              "Traffic." + str(trafficObjIdx) + ".ObjectClass = Unknown\n" + \              "Traffic." + str(trafficObjIdx) + ".Name = Lim" + str(trafficObjIdx).rjust(2, '0') + "\n" + \              "Traffic." + str(trafficObjIdx) + ".Info = Parking limiter " + desc + "\n" + \              "Traffic." + str(trafficObjIdx) + ".Movie.Geometry =\n" + \              "Traffic." + str(trafficObjIdx) + ".Color = 1.0 1.0 1.0\n" + \              "Traffic." + str(trafficObjIdx) + ".Basics.Dimension = 0.1 0.1 " + str(height) + "\n" + \              "Traffic." + str(trafficObjIdx) + ".Basics.Offset = " + str(basicOffset) + " 0.0\n" + \              "Traffic." + str(trafficObjIdx) + ".Basics.Fr12CoM = 0.0\n" + \              "Traffic." + str(trafficObjIdx) + ".Basics.Contour.Mirror = 1\n" + \              "Traffic." + str(trafficObjIdx) + ".Basics.Contour:\n" + \              "\t0.0 0.0\n" + \              "\t0.0 " + str(limLatV / 2) + "\n" + \              "\t" + str(limLatH) + " " + str(limLatV / 2) + "\n" + \              "\t" + str(limLatH) + " 0.0\n" + \              "Traffic." + str(trafficObjIdx) + ".Init.Orientation = 0.0 0.0 0.0\n" + \              "Traffic." + str(trafficObjIdx) + ".Attrib = 0.0 0.0\n" + \              "Traffic." + str(trafficObjIdx) + ".RCSClass = RCS_Car\n" + \              "Traffic." + str(trafficObjIdx) + ".DetectMask = 1 1\n" + \              "Traffic." + str(trafficObjIdx) + ".Route = 0 0\n" + \              "Traffic." + str(trafficObjIdx) + ".Init.Road = " + str(limX) + " " + str(limY) + "\n"        return limStr        def FactoryTrafficObjects(testRun, limitersDict, obstacleList):      trafficObjStr = ""    trafficObjStr += addLimiters(testRun, limitersDict)        for obst in obstacleList:        trafficObjStr += addObstacle(obst)        testRun.addReplacementBefore("DrivMan.OW.Active = 0", trafficObjStr)    testRun.addReplacement("Traffic.N = ", str(trafficObjIdx))        def addLimiters(testRun, limitersDict):    global lim_P1_P_x, lim_P2_P_x, latVPark, lim_H_x1, lim_H_x2, latHPark, latHParkZone, laneWidth, u_Rd, v_Rd, CMSign, trafficObjIdx    limitersStr = ""        if limitersDict["lim_P1_P"].exists:        limDescription = "lim_P1_P - " + limitersDict["lim_P1_P"].limType        limLatV = latVPark        limLatH = LIM_WIDTH        limY = round(v_Rd + CMSign * limLatV / 2, 3)        if limitersDict["lim_P1_P"].limType == "line":            basicOffset = 0.03            limX = round(lim_P1_P_x - limLatH / 2, 3)        else:            basicOffset = 0.0            limX = round(lim_P1_P_x, 3)                limitersStr += getLimiterData(limDescription, limHeight[limitersDict["lim_P1_P"].limType], basicOffset, limLatH, limLatV, limX, limY)        trafficObjIdx += 1    if limitersDict["lim_P2_P"].exists:        limDescription = "lim_P2_P - " + limitersDict["lim_P2_P"].limType        limLatV = latVPark        limLatH = LIM_WIDTH        limY = round(v_Rd + CMSign * limLatV / 2, 3)        if limitersDict["lim_P2_P"].limType == "line":            basicOffset = 0.03            limX = round(lim_P2_P_x - limLatH / 2, 3)        else:            basicOffset = 0.0            limX = round(lim_P2_P_x - limLatH, 3)                limitersStr += getLimiterData(limDescription, limHeight[limitersDict["lim_P2_P"].limType], basicOffset, limLatH, limLatV, limX, limY)        trafficObjIdx += 1    if limitersDict["lim_Rd_P"].exists:        limDescription = "lim_Rd_P - " + limitersDict["lim_Rd_P"].limType        limLatV = LIM_WIDTH        limLatH = latHParkZone        limX = lim_H_x2        if limitersDict["lim_Rd_P"].limType == "line":            basicOffset = 0.03            limY = v_Rd        else:            basicOffset = 0.0            limY = round(v_Rd - CMSign * limLatV / 2, 3)                    limitersStr += getLimiterData(limDescription, limHeight[limitersDict["lim_Rd_P"].limType], basicOffset, limLatH, limLatV, limX, limY)        trafficObjIdx += 1    if limitersDict["lim_P_End"].exists:        limDescription = "lim_P_End - " + limitersDict["lim_P_End"].limType        limLatV = LIM_WIDTH        limLatH = latHParkZone - latHPark * P_curbLimReductionFact * 2        limX = lim_H_x2 + latHPark * P_curbLimReductionFact        if limitersDict["lim_P_End"].limType == "line":            basicOffset = 0.03            limY = round(v_Rd + CMSign * latVPark, 3)        else:            basicOffset = 0.0            limY = round(v_Rd + CMSign * (latVPark + limLatV / 2), 3)                    limitersStr += getLimiterData(limDescription, limHeight[limitersDict["lim_P_End"].limType], basicOffset, limLatH, limLatV, limX, limY)        trafficObjIdx += 1            return limitersStr        # def addObstacle(testRun, shape, xOff, yOff, psi, sizeX=0.5, sizeY=0.5, radius=0.25, height=1, hGround=0):def addObstacle(obst):    global lim_P1_P_x, lim_P2_P_x, latVPark, lim_H_x1, lim_H_x2, latHPark, latHParkZone, laneWidth, u_Rd, v_Rd, CMSign, trafficObjIdx    (shape, xOff, yOff, psi, sizeX, sizeY, radius, height, hGround) = (param for param in obst)        obsX = round(u_Rd - latHPark / 2 + xOff, 3)    obsY = round(v_Rd + CMSign * (latVPark - yOff), 3)    psi = -CMSign * psi        contour = ""    if shape == "rect":        contour = getContourRect(sizeX, sizeY)    elif shape == "cylinder":        contour = getContourCyl(radius)    else:        print("Contour for shape " + shape + " not handled")        obstacleStr = "Traffic." + str(trafficObjIdx) + ".ObjectKind = StatWithName\n" + \                  "Traffic." + str(trafficObjIdx) + ".ObjectClass = Unknown\n" + \                  "Traffic." + str(trafficObjIdx) + ".Name = Obs" + str(trafficObjIdx).rjust(2, '0') + "\n" + \                  "Traffic." + str(trafficObjIdx) + ".Info = Obstacle - " + shape + "\n" + \                  "Traffic." + str(trafficObjIdx) + ".Movie.Geometry =\n" + \                  "Traffic." + str(trafficObjIdx) + ".Color = 1.0 0.0 0.0\n" + \                  "Traffic." + str(trafficObjIdx) + ".Basics.Dimension = 0.1 0.1 " + str(height) + "\n" + \                  "Traffic." + str(trafficObjIdx) + ".Basics.Offset = " + str(hGround) + " 0.0\n" + \                  "Traffic." + str(trafficObjIdx) + ".Basics.Fr12CoM = 0.0\n" + \                  "Traffic." + str(trafficObjIdx) + ".Basics.Contour.Mirror = 1\n" + \                  "Traffic." + str(trafficObjIdx) + ".Basics.Contour:\n" + \                  contour + \                  "Traffic." + str(trafficObjIdx) + ".Init.Orientation = 0.0 0.0 " + str(psi) + "\n" + \                  "Traffic." + str(trafficObjIdx) + ".Attrib = 0.0 0.0\n" + \                  "Traffic." + str(trafficObjIdx) + ".RCSClass = RCS_Car\n" + \                  "Traffic." + str(trafficObjIdx) + ".DetectMask = 1 1\n" + \                  "Traffic." + str(trafficObjIdx) + ".Route = 0 0\n" + \                  "Traffic." + str(trafficObjIdx) + ".Init.Road = " + str(obsX) + " " + str(obsY) + "\n"        trafficObjIdx += 1        return obstacleStr        def getContourRect(sizeX, sizeY):    dimX = str(sizeX)    dimY = str(round(sizeY / 2, 3))        contour = "\t0.0 0.0\n" + \              "\t0.0 " + dimY + "\n" + \              "\t" + dimX + " " + dimY + "\n" + \              "\t" + dimX + " 0.0\n"              return contour        def getContourCyl(radius):    contour = ""    for i in range(0, 181, int(180 / P_circNumSeg)): # for (i = 0°; i <= 180°; i+= segmentSize)        circlePx = round(radius + radius * math.cos(math.radians(i)), 3)        if i == 180:            circlePy = 0 # this is added because sin(180°) != 0 in python (e-16 value)        else:            circlePy = round(radius * math.sin(math.radians(i)), 3)        contour = "\t" + str(circlePx) + " " + str(circlePy) + "\n" + contour            return contour        def fillTrafficObjectIndex(testRun):    global trafficObjIdx    trafficObjIdx = 0    while len(testRun.getValues("Traffic." + str(trafficObjIdx) + ".Init.Road")) > 0:        trafficObjIdx += 1