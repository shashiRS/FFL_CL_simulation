#********************************************************************# System Imports#********************************************************************import sysimport impimp.reload(sys)# sys.setdefaultencoding('utf8')import cmTestRunSimpleimport mathimport numpy as npimport scipy.interpolatefrom collections import namedtuplefrom Constants import *# Interpolation tables for determining stopping distance based on ego vehicle velocityCM_EGO_VEHICLE_VELOCITY     = [1,     2,     3,     4,     5,     6,     7,     8,     9,     9.4,   9.5,   10,    11,    12,    13,    14,     15,     16,     17,     18,     19,     20] # km/hCM_DECELERATION             = [1,     1,     1,     2,     2,     2,     2,     3,     3,     3,     4,     4,     4,     4,     4,     4,      4,      4,      4,      4,      4,      4] # m/s^2, decelaration for the vehicle stopping maneuversCM_STOP_DIST_FWD            = [0.107, 0.285, 0.548, 0.551, 0.783, 1.053, 1.347, 1.282, 1.553, 1.665, 2.776, 2.972, 3.378, 3.802, 4.242, 4.703,  5.184,  5.693,  6.158,  6.726,  7.286,  7.858] # m, distance required for stopping the forwards driving ego vehicleCM_STOP_DIST_BWD            = [0.000, 0.177, 0.388, 0.394, 0.593, 0.821, 1.088, 1.016, 1.252, 1.356, 1.114, 1.220, 3.222, 3.630, 4.063, 4.513,  4.984,  5.477,  5.999,  6.531,  7.058,  7.553] # m, distance required for stopping the backwards driving ego vehicleyInterpDeceleration         = scipy.interpolate.interp1d(CM_EGO_VEHICLE_VELOCITY, CM_DECELERATION, fill_value='extrapolate')yInterpStopDistFwd          = scipy.interpolate.interp1d(CM_EGO_VEHICLE_VELOCITY, CM_STOP_DIST_FWD, fill_value='extrapolate')yInterpStopDistBwd          = scipy.interpolate.interp1d(CM_EGO_VEHICLE_VELOCITY, CM_STOP_DIST_BWD, fill_value='extrapolate')laneWidth     = 0egoStartX     = 0egoStartY     = 0#====================================================================# Test Factories#====================================================================def init(testRun):    global laneWidth, egoStartX, egoStartY        tempList = testRun.getValues("Road.Link.0.LaneSection.0.LaneR.0 = ")    laneWidth = float(tempList[1])    tempList = testRun.getValues("Road.VhclStartPos = ")    egoStartX = float(tempList[0])    egoStartY = float(tempList[1])    def FactoryObstacle(testRun, type="pole", radius=0.02, length=0.2, width=0.4, height=1.5, groundClearance=0.0, psi=0.0, lateralOffset=0.0):    contour = ""    motion  = ""    angOffX = 0 # longitudinal offset required for cuboid obstacles to ensure the closest colision point in the driving tube does not drop below P_collisionPointX        if type == "pole" or type == "cone":        testRun.addReplacement("Traffic.1.Info = ", type.capitalize())        if type == "cone":            # TODO: change this to a cone movie model once available            # bollard            # testRun.addReplacement("Traffic.1.Movie.Geometry =", " 3D/StreetFurniture/BollardRoad_01_1.mobj")            # radius = 0.04            # height = 0.81            # barrel            testRun.addReplacement("Traffic.1.Movie.Geometry =", " 3D/StreetFurniture/Construction/Barrel_Red.mobj")            radius = 0.29            height = 0.88                for i in range(0, 181, int(180 / CM_CIRC_OBST_NUM_SEG)): # for (i = 0°; i <= 180°; i+= segmentSize)            circlePx = round(radius + radius * math.cos(math.radians(i)), 3)            if i == 180:                circlePy = 0 # this is added because sin(180°) != 0 in python (e-16 value)            else:                circlePy = round(radius * math.sin(math.radians(i)), 3)            contour = "\t" + str(circlePx) + " " + str(circlePy) + "\n" + contour    elif type == "box" or type == "wall" or type == "curb":        testRun.addReplacement("Traffic.1.Info = ", type.capitalize())        contour = "\t0.0 0.0\n\t0.0 " + str(width/2) + "\n\t" + str(length) + " " + str(width/2) + "\n\t" + str(length) + " 0.0"              # for rotated objects, ensure that collision does not occur before the desired stopping distance (consider only what is within the ego driving tube)        angOffX = calcRotationOffset(psi, width)    elif type == "pedestrian":        testRun.addReplacement("Traffic.1.Info = ", "Pedestrian adult dummy")        testRun.addReplacement("Traffic.1.Movie.Geometry =", " 3D/NCAP/Pedestrian_Adult_EuroNCAP_2015_Static.mobj")        contour = "\t0.0 0.0\n\t0.0 0.31\n\t0.79 0.31\n\t0.79 0.0"        height = 1.81    elif type == "car":        testRun.addReplacement("Traffic.1.Info = ", "Vehicle")        # VW Passat B8        testRun.addReplacement("Traffic.1.Movie.Geometry =", " VW_Passat_B8_Variant_noWheels_rotated_black.obj")        contour = "\t0.000 0.000\n\t0.050 0.500\n\t0.120 0.685\n\t0.250 0.770\n\t0.740 0.916\n\t4.350 0.916\n\t4.500 0.850\n\t4.767 0.500\n\t4.767 0.000"        width = EGO_WIDTH        height = 1.5        groundClearance = 0.2        angOffX = calcRotationOffset(psi, width)    elif type == "motorcyle":        testRun.addReplacement("Traffic.1.Info = ", "Motorcycle")        # Ducati Panigale 1199        testRun.addReplacement("Traffic.1.Movie.Geometry =", " 3D/Vehicles/Ducati_Panigale1199_2012_Traffic.obj")        contour = "\t0.0 0.0\n\t0.0 0.215\n\t0.7 0.215\n\t1.5 0.405\n\t1.75 0.405\n\t1.85 0.15\n\t2.02 0.15\n\t2.02 0.0" # this is only a rough estimate        width = 0.81        height = 1.1        angOffX = calcRotationOffset(psi, width)    elif type == "bobby":        testRun.addReplacement("Traffic.1.Info = ", "Bobby Car")        # Girl on scooter        testRun.addReplacement("Traffic.1.Movie.Geometry =", " 3D/People/Scooter_Female_Child_01.manim")        testRun.addReplacement("Traffic.1.ObjectKind = ", "Movable")        testRun.addReplacement("Traffic.1.ObjectClass = ", "Bicycle")        testRun.addReplacement("Traffic.1.Traffic.1.RCSClass = ", "RCS_Bicycle")        contour = "\t0.0 0.0\n\t0.0 0.2\n\t0.91 0.2\n\t0.91 0.0" # box shaped contour        width = 0.4        height = 1.04        angOffX = calcRotationOffset(psi, width)                # elements required to freeze position of the traffic object        motion = "\nTraffic.1.Init.v = 0.0" + \                 "\nTraffic.1.FreeMotion = 0" + \                 "\nTraffic.1.Man.TreatAtEnd = FreezePos"                testRun.addReplacement("Traffic.1.Basics.Offset = ", "0 " + str(groundClearance)) # height above ground    testRun.addReplacement("Traffic.1.Basics.Dimension = ", "0.001 0.001 " + str(height)) # length and width are filled by contour values; only height value is considered    testRun.addReplacement("Traffic.1.Basics.Contour:", "\n" + contour)    testRun.addReplacement("Traffic.1.Init.Orientation = ", "0.0 0.0 " + str(psi))        obsStartX = P_collisionPointX + angOffX    obsStartY = (-1) * laneWidth / 2 + lateralOffset    testRun.addReplacement("Traffic.1.Init.Road = ", str(obsStartX) + " " + str(obsStartY) + motion)        def FactorySimpleCollision(testRun, vEgo=5.0, stopOff=0.3):    stopDist = yInterpStopDistFwd(vEgo) # stopping distance value based on ego vehicle velocity    scanDist = (vEgo / 3.6) * P_scanningTime # scanning distance considering a constant ego vehicle velocity (ego vehicle will start from standstill)    totalDist = scanDist + stopDist        # ego vehicle start position    egoStartX = P_collisionPointX - totalDist - stopOff - EGO_LENGTH    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        # driving stop trigger    triggerDist = P_collisionPointX - stopDist - stopOff - (EGO_LENGTH - VHCL_SROAD_STARTOFF) # (EGO_LENGTH - VHCL_SROAD_STARTOFF) is subtracted so the front bumper reaches the collision point at standstill    testRun.addReplacement("\tEval Vhcl.sRoad >= ", str(triggerDist) + " ? ManJump(\"+1\")")    # drive maneuvers    maneuverForward(testRun, velocityEgo=vEgo, maneuverIdx=2)        def FactoryStopAndGo(testRun, vEgo=5.0, stopOff=1.0, initialOff = 15.0, dummyDriveDist = 10.0):    stopDist = yInterpStopDistFwd(vEgo) # stopping distance value based on ego vehicle velocity    additionalDriveDist = 0 # m - additional driving distance considered for higher ego velocity (to stailize ego velocity and increase stopping distance accuracy)        if vEgo > 8.0:        additionalDriveDist = 3.0 # TODO: change this to an interpolation value if set value is not enough for higher velocities        initialOff += additionalDriveDist        dummyDriveDist += additionalDriveDist        # dummy car start position    dummyStartX = P_stopAndGoDummyStart    dummyStartY = (-1) * laneWidth / 2    testRun.addReplacement("Traffic.1.Init.Road = ", str(dummyStartX) + " " + str(dummyStartY))        # ego vehicle start position    egoStartX = dummyStartX - initialOff - EGO_LENGTH    egoStartX = round(egoStartX, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        # driving stop triggers    # These can be shifted as driving triggers in maneuverForward function, but this approach leads to a more accurate drive (i.e. the vehicle stops closer to the collision point).    totalDummyDriveDist = dummyDriveDist + additionalDriveDist    firstDriveTrigger = dummyStartX - stopDist - stopOff - (EGO_LENGTH - VHCL_SROAD_STARTOFF) # (EGO_LENGTH - VHCL_SROAD_STARTOFF) is subtracted so the front bumper reaches the collision point at standstill    secondDriveTrigger = firstDriveTrigger + dummyDriveDist    firstDriveTrigger = round(firstDriveTrigger, 3)    secondDriveTrigger = round(secondDriveTrigger, 3)        testRun.addReplacement("\tEval first() ? Qu::FirstDriveTrigger = ", str(firstDriveTrigger))    testRun.addReplacement("\tEval first() ? Qu::SecondDriveTrigger = ", str(secondDriveTrigger))        # dummy car movement    # dummy car velocity = ego car velocity    testRun.addReplacement("Traffic.1.Man.2.LongDyn = v ", str(vEgo))    testRun.addReplacement("Traffic.1.Man.3.LongDyn = v ", str(vEgo))    testRun.addReplacement("Traffic.1.Man.3.Limit = s ", str(dummyDriveDist - 1.0))        # drive maneuvers    maneuverForward(testRun, velocityEgo=vEgo, maneuverIdx=2)    maneuverForward(testRun, velocityEgo=vEgo, maneuverIdx=5)        def FactoryPerpendicularParking(testRun, vEgo=5.0, lenP=4.5, limPEnd="curb_t", latDist=1.0, scanDist=25.0, longOff=6.0):    # lenP = parking slot length    # limPEnd = limiter type for curb side limiter    # latDist = lateral offset between ego and parked vehicles    # scanDist = scanning maneuver length    # longOff = distance between the middle of the parking slot and scanning end position (parking maneuver starts from this longitudinal offset)        # parking slot layout    parkSlotPadding = 0 # padding at the curb side edge of the parking area (used only when limiters are present)    limLatOff = 0 # lateral offset for curb side limiter    if limPEnd != "none":        parkSlotPadding = 0.25        limLatOff = (-1) * (laneWidth + lenP + P_limiterWidth) # (-1) is CarMaker sign for side        limLatOff = round(limLatOff, 3)        testRun.addReplacement("Traffic.2.Init.Road = 35.5 ", str(limLatOff))    else:        testRun.addReplacement("Traffic.2.Init.Road = ", "0 -25") # instead of deleting limiter, move outside sensor range            parkSlotLength = lenP + parkSlotPadding        limHeight = 0.001    if limPEnd == "curb_t":        limHeight = 0.03    elif limPEnd == "wall":        limHeight = 3.0    # TODO: put padding and limiter Height for each limiter in a named tuple    testRun.addReplacement("Traffic.2.Basics.Dimension = 9.0 0.15 ", str(limHeight))            # set parking slot length (adjust for entire parking area)    # TODO: adjust lane section width settings for left side as well    for i in range(1, 4):        testRun.addReplacement("Road.Link.0.LaneSection." + str(i) + ".LaneR.1 = 0 ", str(parkSlotLength) + " " + str(parkSlotLength) + " 13 0 0 0")            # ego vehicle start position    egoStartX = P_parkSlotMiddle - scanDist + longOff    egoStartX = round(egoStartX, 3)    egoStartY = (-1) * (laneWidth / 2 - latDist - EGO_WIDTH / 2) # TODO: adjust for left side as well    egoStartY = round(egoStartY, 3)    testRun.addReplacement("Road.VhclStartPos = ", str(egoStartX) + " " + str(egoStartY))        # drive maneuvers    maneuverForward(testRun, velocityEgo=vEgo, driveDist=scanDist, maneuverIdx=2)        #====================================================================# Auxiliary functions#====================================================================    def calcRotationOffset(obstacleAngle, obstacleWidth):    angOffX = 0 # longitudinal offset required for cuboid obstacles to ensure the closest colision point in the driving tube does not drop below P_collisionPointX    if obstacleAngle != 0:        obsWidth = min(obstacleWidth, EGO_WIDTH) # do not consider obstacle width that falls outside the driving tube        angOffX = math.sin(math.radians(obstacleAngle)) * (obsWidth / 2) # angOffX is the longitudinal leg in the right triangle with (obsWidth / 2) as hypotenuse |TODO: check if (obsWidth / 2) should be considered the other leg        angOffX = round(abs(angOffX), 3)    return angOffX        def maneuverForward(testRun, velocityEgo=5.0, driveDist=0.0, maneuverIdx=2):    decelaration = yInterpDeceleration(velocityEgo) # decelartion value based on ego vehicle velocity    stopDist = yInterpStopDistFwd(velocityEgo) # stopping distance value based on ego vehicle velocity        if driveDist > 0:        testRun.addReplacement("DrivMan." + str(int(maneuverIdx)) + ".Cmds:", "" + \                                                          "\n\t# # Hold brake to prevent vehicle from unwanted movement" + \                                                          "\n\tEval DM.ManTime <= 1.0 ? DM.Brake = 0.3" + \                                                          "\n\t\"\"" + \                                                          "\n\t# Scanning with constant velocity complete" + \                                                          "\n\tEval first() ? Qu::StartPos = Vhcl.sRoad" + \                                                          "\n\tEval Vhcl.sRoad >= StartPos + " + str(driveDist - stopDist) + " ? ManJump(\"+1\")")            testRun.addReplacement("DrivMan." + str(int(maneuverIdx)) + ".LongDyn = VelControl ", str(velocityEgo) + " 0.0 1.0 0.0 1 0.0")    testRun.addReplacement("DrivMan." + str(int(maneuverIdx + 1)) + ".LongDyn = Stop ", str(decelaration) + " 0")    